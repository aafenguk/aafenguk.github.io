<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>aafeng</title>
  <icon>https://www.gravatar.com/avatar/a176a52d9d4ac7d9f90a5204a7d87bcd</icon>
  <subtitle>aafeng&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.aafeng.uk/"/>
  <updated>2020-06-08T15:07:11.141Z</updated>
  <id>https://www.aafeng.uk/</id>
  
  <author>
    <name>aafeng</name>
    <email>aafenguk@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用Kibana可视化你的数据</title>
    <link href="https://www.aafeng.uk/kibana-visualization/"/>
    <id>https://www.aafeng.uk/kibana-visualization/</id>
    <published>2020-06-08T15:07:11.141Z</published>
    <updated>2020-06-08T15:07:11.141Z</updated>
    
    <content type="html"><![CDATA[<p>把数据保存到Elasticsearch之后，有一个重要的工作就是要对数据进行可视化，以便下一步的分析。下面通过一个官方的数据集来介绍如何通过Kibana进行数据可视化。</p><p><img src="/images/technology/kibana/kibana.png" alt="Kibana"></p><a id="more"></a><h2 id="操作环境"><a href="#操作环境" class="headerlink" title="操作环境"></a>操作环境</h2><p>Elasticsearch: 7.7.0<br>Kibana: 7.7.0</p><h2 id="下载并导入数据"><a href="#下载并导入数据" class="headerlink" title="下载并导入数据"></a>下载并导入数据</h2><p>从官网下载如下的数据集：<a href="https://download.elastic.co/demos/kibana/gettingstarted/accounts.zip" rel="external nofollow noopener noreferrer" target="_blank">https://download.elastic.co/demos/kibana/gettingstarted/accounts.zip</a></p><p>解压缩后会得到accounts.json这个文件，其大小大约为240K。</p><p>运行如下命令将数据导入ES：</p><pre><code>curl -H &apos;Content-Type: application/x-ndjson&apos; -XPOST &apos;localhost:9200/bankdemo/account/_bulk?pretty&apos; --data-binary @accounts.json</code></pre><p>在Kibana的Devtool中验证数据已经被导入：</p><pre><code>GET /_cat/indices?vGET bankdemo/_search?q=*:*</code></pre><p>其输出类似于：</p><pre><code>{  &quot;took&quot; : 6,  &quot;timed_out&quot; : false,  &quot;_shards&quot; : {    &quot;total&quot; : 1,    &quot;successful&quot; : 1,    &quot;skipped&quot; : 0,    &quot;failed&quot; : 0  },  &quot;hits&quot; : {    &quot;total&quot; : {      &quot;value&quot; : 1000,      &quot;relation&quot; : &quot;eq&quot;    },    &quot;max_score&quot; : 1.0,    &quot;hits&quot; : [      {        &quot;_index&quot; : &quot;bankdemo&quot;,        &quot;_type&quot; : &quot;account&quot;,        &quot;_id&quot; : &quot;1&quot;,        &quot;_score&quot; : 1.0,        &quot;_source&quot; : {          &quot;account_number&quot; : 1,          &quot;balance&quot; : 39225,          &quot;firstname&quot; : &quot;Amber&quot;,          &quot;lastname&quot; : &quot;Duke&quot;,          &quot;age&quot; : 32,          &quot;gender&quot; : &quot;M&quot;,          &quot;address&quot; : &quot;880 Holmes Lane&quot;,          &quot;employer&quot; : &quot;Pyrami&quot;,          &quot;email&quot; : &quot;amberduke@pyrami.com&quot;,          &quot;city&quot; : &quot;Brogan&quot;,          &quot;state&quot; : &quot;IL&quot;        }      },……</code></pre><h2 id="创建索引模式-Index-Pattern"><a href="#创建索引模式-Index-Pattern" class="headerlink" title="创建索引模式(Index Pattern)"></a>创建索引模式(Index Pattern)</h2><p>索引模式(Index Pattern)可以针对多个索引，因此在创建时支持通配符。</p><p>在Kibana的页面中选择：Kibana -&gt; Management -&gt; Index Patterns -&gt; Create index pattern</p><p><img src="/images/technology/kibana/visualization1.png" alt="Kibana"></p><p>创建完毕后会看到如下界面：</p><p><img src="/images/technology/kibana/visualization2.png" alt="Kibana"></p><p>可以看到有的字段可以被搜索的(Searchable)，有的字段是可以被聚合的(Aggregatable)。如果需要的话，可以自己更改这些字段的属性。</p><h2 id="在Kibana中查看数据"><a href="#在Kibana中查看数据" class="headerlink" title="在Kibana中查看数据"></a>在Kibana中查看数据</h2><p>单击Discovery后，可以输入KQL来检索数据。</p><p>比如，输入：</p><pre><code>balance &gt;= 47500 and employer:a*</code></pre><p>你会看到：</p><p><img src="/images/technology/kibana/visualization3.png" alt="Kibana"></p><p>KQL的语法和SQL非常相似，简单好用，比如：</p><pre><code>balance &gt;= 47500 and employer:a* and account_number &gt; 100</code></pre><p>可以通过左侧菜单选择索引，以及字段。    </p><h2 id="Kibana可视化：饼图"><a href="#Kibana可视化：饼图" class="headerlink" title="Kibana可视化：饼图"></a>Kibana可视化：饼图</h2><p>选择Visualize -&gt; Create visualization -&gt; Pie -&gt; Bank Demo</p><p><img src="/images/technology/kibana/visualization4.png" alt="Kibana"></p><p>由于目前没有对源数据进行定义，因此，初始饼图看起来这是这样的：</p><p><img src="/images/technology/kibana/visualization5.png" alt="Kibana"></p><p>选择Buckets -&gt; Add -&gt; Split slices -&gt; Range，同时设定不同的范围：</p><p><img src="/images/technology/kibana/visualization6.png" alt="Kibana"></p><p>可以看到更新后的饼图：</p><p><img src="/images/technology/kibana/visualization7.png" alt="Kibana"></p><p>还可以添加一个SUB-BUCKET，在现有聚合的基础上做进一步的划分：</p><p><img src="/images/technology/kibana/visualization8.png" alt="Kibana"></p><p>最后不要忘记保存你的Visualization。</p>]]></content>
    
    <summary type="html">
    
      使用Kibana可视化你的数据
    
    </summary>
    
      <category term="技术" scheme="https://www.aafeng.uk/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ELK" scheme="https://www.aafeng.uk/tags/ELK/"/>
    
  </entry>
  
  <entry>
    <title>编程思想</title>
    <link href="https://www.aafeng.uk/programming-thinking/"/>
    <id>https://www.aafeng.uk/programming-thinking/</id>
    <published>2020-06-07T20:07:13.286Z</published>
    <updated>2020-06-07T20:07:13.286Z</updated>
    
    <content type="html"><![CDATA[<p>最近和朋友聊天，正好他家的孩子也在学习编程。于是就聊到了怎么教孩子编程，该教些什么，以及什么是编程思想的问题上。</p><p><img src="/images/technology/programming-thinking.jpg" alt="编程思想"><br>图源：Pixabay</p><a id="more"></a><p>其实在很多年前就和同事们讨论过这个问题。大家一致认为编程的过程其实就是一种逻辑思维的过程，是如何将一个现实世界的问题逐步分解，再用算法将其高效实现的过程。因此，在整个编程思维的训练过程中，最重要的是训练思维的逻辑性。</p><p>记得上大学的时候，在数学系，计算机系，和计算中心等好几个系中都有程序设计的高手，这些人都有一个共同的特点，就是他们的数学功底都非常好。有的是数学系科班出身的，有的虽然不是数学系毕业的，但数学功底是非常深厚的。记得曾经一起做过项目的一个南开大学数学系退休返聘的老教授，负责最核心的算法部分，每次手写的代码，成百上千行，几乎都是一次性通过测试。他缜密的思维能力让人佩服万分。究其原因，其实就是数学好的人，无一例外的，逻辑思维都非常清晰，而这是在编程中最为重要的部分。</p><p>曾经有人打过一个比方，学习编程的过程，有点类似金庸小说中的武功修炼。不仅有各种实用的招式，也需要有深厚内功的辅助才行。在编程的学习中，数据结构，算法等基础性课程就好比是内功。如果内功修炼的够深厚了，无论用什么编程语言，什么框架，都会使的得心应手，做出优秀的软件来。当然，在内功好的基础上，如果能辅以高效的框架和编程语言，就能更加有效的开发软件。</p><p>回到教孩子编程这个问题上来，我认为首先是培养他们的兴趣。但在培养的过程中，一定注意启发他们积极思考，将程序设计中的逻辑性贯穿到每个例子中。一旦他们真正掌握了这种思维方式，以后再学习任何其他语言或者框架时才能举一反三，事半功倍。</p>]]></content>
    
    <summary type="html">
    
      编程思想
    
    </summary>
    
      <category term="技术" scheme="https://www.aafeng.uk/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Elasticsearch的中文分词</title>
    <link href="https://www.aafeng.uk/elasticsearch-chinese-tokenizer/"/>
    <id>https://www.aafeng.uk/elasticsearch-chinese-tokenizer/</id>
    <published>2020-06-05T21:32:41.847Z</published>
    <updated>2020-06-05T21:32:41.847Z</updated>
    
    <content type="html"><![CDATA[<p>以下的步骤都是基于Elasticsearch和Kibana的基础上的，如果还没有安装，建议参考我前面的文章。</p><p><img src="/images/blockchain/hive/es.png" alt="Elasticsearch"></p><a id="more"></a><h2 id="什么是分词和默认分词器？"><a href="#什么是分词和默认分词器？" class="headerlink" title="什么是分词和默认分词器？"></a>什么是分词和默认分词器？</h2><p>所谓分词，就是把一段话拆解为若干词元(token)，再将其保存至索引中以便下一步搜索。在ES中有现成的分词器，只不过这些分词器对中文的处理不尽人意。看一个例子：</p><p>在Kibana devtool中输入：</p><pre><code>GET _analyze{      &quot;text&quot;: &quot;are you ok?&quot;  }</code></pre><p>这等同于：</p><pre><code>GET _analyze{      &quot;analyzer&quot;: &quot;standard&quot;,    &quot;text&quot;: &quot;are you ok?&quot;  }</code></pre><p>可以看到其返回结果为：</p><pre><code>{  &quot;tokens&quot; : [    {      &quot;token&quot; : &quot;are&quot;,      &quot;start_offset&quot; : 0,      &quot;end_offset&quot; : 3,      &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,      &quot;position&quot; : 0    },    {      &quot;token&quot; : &quot;you&quot;,      &quot;start_offset&quot; : 4,      &quot;end_offset&quot; : 7,      &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,      &quot;position&quot; : 1    },    {      &quot;token&quot; : &quot;ok&quot;,      &quot;start_offset&quot; : 8,      &quot;end_offset&quot; : 10,      &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,      &quot;position&quot; : 2    }  ]}</code></pre><p>在这里，将”are you ok?”分成了三个词元：”are”, “you”，”ok”。这样的分词没有任何问题，毕竟在英文中就是用空格来分隔各个单词的。</p><p>但如果我们再尝试一段中文的话：</p><pre><code>GET _analyze{      &quot;text&quot;: &quot;我爱我的祖国&quot;  }</code></pre><p>其输出结果为：</p><pre><code>{  &quot;tokens&quot; : [    {      &quot;token&quot; : &quot;我&quot;,      &quot;start_offset&quot; : 0,      &quot;end_offset&quot; : 1,      &quot;type&quot; : &quot;&lt;IDEOGRAPHIC&gt;&quot;,      &quot;position&quot; : 0    },    {      &quot;token&quot; : &quot;爱&quot;,      &quot;start_offset&quot; : 1,      &quot;end_offset&quot; : 2,      &quot;type&quot; : &quot;&lt;IDEOGRAPHIC&gt;&quot;,      &quot;position&quot; : 1    },    {      &quot;token&quot; : &quot;我&quot;,      &quot;start_offset&quot; : 2,      &quot;end_offset&quot; : 3,      &quot;type&quot; : &quot;&lt;IDEOGRAPHIC&gt;&quot;,      &quot;position&quot; : 2    },    {      &quot;token&quot; : &quot;的&quot;,      &quot;start_offset&quot; : 3,      &quot;end_offset&quot; : 4,      &quot;type&quot; : &quot;&lt;IDEOGRAPHIC&gt;&quot;,      &quot;position&quot; : 3    },    {      &quot;token&quot; : &quot;祖&quot;,      &quot;start_offset&quot; : 4,      &quot;end_offset&quot; : 5,      &quot;type&quot; : &quot;&lt;IDEOGRAPHIC&gt;&quot;,      &quot;position&quot; : 4    },    {      &quot;token&quot; : &quot;国&quot;,      &quot;start_offset&quot; : 5,      &quot;end_offset&quot; : 6,      &quot;type&quot; : &quot;&lt;IDEOGRAPHIC&gt;&quot;,      &quot;position&quot; : 5    }  ]}</code></pre><p>这样的分词结果是明显错误的，或者说是没什么用的。</p><h2 id="安装elasticsearch中文分词器"><a href="#安装elasticsearch中文分词器" class="headerlink" title="安装elasticsearch中文分词器"></a>安装elasticsearch中文分词器</h2><p>常见的elasticsearch中文分词器包括：<a href="https://www.elastic.co/guide/en/elasticsearch/plugins/current/analysis-smartcn.html" rel="external nofollow noopener noreferrer" target="_blank">smartcn</a>和<a href="https://github.com/medcl/elasticsearch-analysis-ik" rel="external nofollow noopener noreferrer" target="_blank">ik</a>。</p><p>下面以ik分词器为例来说明如何安装和使用elasticsearch中文分词器。</p><p>首先需要注意，分词器的版本一定要和elasticsearch版本匹配。比如：我使用的elasticsearch版本是7.7.0，那么，对应的分词器版本也应该是7.7.0。</p><p>完整的ik版本列表可以在这里找到：<a href="https://github.com/medcl/elasticsearch-analysis-ik/releases" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/medcl/elasticsearch-analysis-ik/releases</a></p><p>首先进行安装：</p><pre><code>./elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.7.0/elasticsearch-analysis-ik-7.7.0.zip</code></pre><p>验证一下是否成功安装：</p><pre><code>./elasticsearch-plugin list</code></pre><p>它会显示刚安装的中文分词器。</p><p>同时可以看到，在plugins目录下多了一个analysis-ik子目录。</p><p>安装结束后，就会有两个分词器：ik_max_word和ik_smart。这两个分词器的算法不同。第一个会尽量分出更多的中文词，但会占用更多空间。而第二个则不会。一般情况下，使用ik_smart就足够了。</p><p>比如：运行如下查询：</p><pre><code>GET _analyze{      &quot;analyzer&quot;: &quot;ik_smart&quot;,    &quot;text&quot;: &quot;我爱我的祖国&quot;  }</code></pre><p>其结果为：</p><pre><code>{  &quot;tokens&quot; : [    {      &quot;token&quot; : &quot;我&quot;,      &quot;start_offset&quot; : 0,      &quot;end_offset&quot; : 1,      &quot;type&quot; : &quot;CN_CHAR&quot;,      &quot;position&quot; : 0    },    {      &quot;token&quot; : &quot;爱我&quot;,      &quot;start_offset&quot; : 1,      &quot;end_offset&quot; : 3,      &quot;type&quot; : &quot;CN_WORD&quot;,      &quot;position&quot; : 1    },    {      &quot;token&quot; : &quot;的&quot;,      &quot;start_offset&quot; : 3,      &quot;end_offset&quot; : 4,      &quot;type&quot; : &quot;CN_CHAR&quot;,      &quot;position&quot; : 2    },    {      &quot;token&quot; : &quot;祖国&quot;,      &quot;start_offset&quot; : 4,      &quot;end_offset&quot; : 6,      &quot;type&quot; : &quot;CN_WORD&quot;,      &quot;position&quot; : 3    }  ]}</code></pre><h2 id="定义自己的词条"><a href="#定义自己的词条" class="headerlink" title="定义自己的词条"></a>定义自己的词条</h2><p>在ik分词器中，所有的词条文件都保存在elasticsearch-7.7.0/config/analysis-ik中。如果想要定义自己的词条，需要以下几个步骤：</p><p>首先在这个目录中创建一个新的词条文件，并将新的词条每行添加一个</p><pre><code>新词条1新词条2....</code></pre><p>接下来，在配置文件IKAnalyzer.cfg.xml中添加对上一步自建词条文件的引用：</p><pre><code>&lt;entry key=&quot;ext_dict&quot;&gt;new_dict.dic&lt;/entry&gt;</code></pre><p>之后需要重新启动ES才能生效。</p><h2 id="在索引中使用中文分词器"><a href="#在索引中使用中文分词器" class="headerlink" title="在索引中使用中文分词器"></a>在索引中使用中文分词器</h2><p>创建索引：</p><pre><code>curl -X PUT localhost:9200/ik1</code></pre><p>或者在Kibana中：</p><pre><code>PUT ik1{&quot;settings&quot;: {  &quot;analysis&quot;: {    &quot;analyzer&quot;: {      &quot;es_std&quot;: {        &quot;type&quot;: &quot;ik_smart&quot;      }    }  }}}</code></pre><p>查看ik1</p><pre><code>GET ik1</code></pre><p>试用分词器：</p><pre><code>GET /ik1/_analyze{  &quot;analyzer&quot;: &quot;ik_smart&quot;,   &quot;text&quot;: &quot;我和我的祖国&quot;}</code></pre><p>在Python交互界面中添加一条数据：</p><pre><code>from elasticsearch import Elasticsearches = Elasticsearch()es.index(index=&quot;ik1&quot;, id=1, body={&quot;text&quot;: &quot;我和我的祖国&quot;})</code></pre><p>测试以下查询：</p><pre><code>POST ik1/_search{    &quot;query&quot;: {        &quot;query_string&quot;: {            &quot;query&quot;: &quot;祖国&quot;,            &quot;fields&quot;: [&quot;text&quot;]        }    }}</code></pre><p>其返回值为：</p><pre><code>{  &quot;took&quot; : 5,  &quot;timed_out&quot; : false,  &quot;_shards&quot; : {    &quot;total&quot; : 1,    &quot;successful&quot; : 1,    &quot;skipped&quot; : 0,    &quot;failed&quot; : 0  },  &quot;hits&quot; : {    &quot;total&quot; : {      &quot;value&quot; : 1,      &quot;relation&quot; : &quot;eq&quot;    },    &quot;max_score&quot; : 0.5753642,    &quot;hits&quot; : [      {        &quot;_index&quot; : &quot;ik1&quot;,        &quot;_type&quot; : &quot;_doc&quot;,        &quot;_id&quot; : &quot;1&quot;,        &quot;_score&quot; : 0.5753642,        &quot;_source&quot; : {          &quot;text&quot; : &quot;我和我的祖国&quot;        }      }    ]  }}</code></pre>]]></content>
    
    <summary type="html">
    
      Elasticsearch的中文分词
    
    </summary>
    
      <category term="技术" scheme="https://www.aafeng.uk/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>自制Pizza</title>
    <link href="https://www.aafeng.uk/pizza/"/>
    <id>https://www.aafeng.uk/pizza/</id>
    <published>2020-06-04T21:21:07.977Z</published>
    <updated>2020-06-04T21:21:07.977Z</updated>
    
    <content type="html"><![CDATA[<p>自从宅在家中后，很多闲置多年的电器开始启用了。媳妇最近开始使用面包机制作面包，其口感和味道比超市买的买包好吃了不止一个档次。最近还发现了一个功能：可以用面包机制作pizza所需的面饼。</p><p>正好孩子们都超级喜欢pizza，于是买齐了食材，开始制作pizza。先上一张成品图：</p><p><img src="/images/food/pizza/1.jpg" alt="Pizza"></p><a id="more"></a><p>首先将面包机中发好的面团拿出来擀成pizza的面饼：</p><p><img src="/images/food/pizza/2.jpg" alt="Pizza"></p><p>将面饼上抹上西红柿酱，由于所有人都喜欢Cheese，因此先放了一层Cheese：</p><p><img src="/images/food/pizza/3.jpg" alt="Pizza"></p><p>接下来将Pepperoni摆匀：</p><p><img src="/images/food/pizza/4.jpg" alt="Pizza"></p><p>再摆放洋葱，角瓜，蘑菇，最后上面再放一层Cheese：</p><p><img src="/images/food/pizza/5.jpg" alt="Pizza"></p><p>烤箱预热后烤了20分钟就好了，既简单又好吃！</p>]]></content>
    
    <summary type="html">
    
      自制Pizza
    
    </summary>
    
      <category term="美食" scheme="https://www.aafeng.uk/categories/%E7%BE%8E%E9%A3%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>将Hive文章保存到Elasticsearch的尝试</title>
    <link href="https://www.aafeng.uk/hive-elasticsearch/"/>
    <id>https://www.aafeng.uk/hive-elasticsearch/</id>
    <published>2020-06-04T11:15:18.116Z</published>
    <updated>2020-06-04T11:15:18.116Z</updated>
    
    <content type="html"><![CDATA[<p>一直对Hive的搜索功能不是很满意。在工作中使用过不同的框架，这些框架提供的搜索功能中，facet，关键字标红等可以说是标配。但在Hive中一样都没有。其原因我也能理解，毕竟从链上读取数据，这些数据中不包含需要的信息，自然也不太容易实现这些功能。那么，如果把链上数据保存到Solr或者Elasticsearch中，不就能增强其搜索功能了吗？下面记录一下把Hive中的文章信息保存到Elasticsearch中的步骤。当然，下面只是一个简单的实验，想做到一个真正能工作的网站还有很多工作要做。</p><p><img src="/images/blockchain/hive/es.png" alt="Elasticsearch"></p><a id="more"></a><h2 id="安装Elasticsearch"><a href="#安装Elasticsearch" class="headerlink" title="安装Elasticsearch"></a>安装Elasticsearch</h2><p>下载Elasticsearch:</p><p><a href="https://www.elastic.co/cn/downloads/elasticsearch" rel="external nofollow noopener noreferrer" target="_blank">https://www.elastic.co/cn/downloads/elasticsearch</a></p><p>解压缩：</p><pre><code>tar xvf elasticsearch-7.7.0-linux-x86_64.tar.gz</code></pre><p>运行：</p><pre><code>cd elasticsearch-7.7.0/bin ./elasticsearch</code></pre><p>在本地用curl测试一下：</p><pre><code>curl localhost:9200</code></pre><p>其输出应类似于：</p><pre><code>{  &quot;name&quot; : &quot;YOUR_SERVER_NAME&quot;,  &quot;cluster_name&quot; : &quot;elasticsearch&quot;,  &quot;cluster_uuid&quot; : &quot;liHA066AQJeE91lv8lLqig&quot;,  &quot;version&quot; : {    &quot;number&quot; : &quot;7.7.0&quot;,    &quot;build_flavor&quot; : &quot;default&quot;,    &quot;build_type&quot; : &quot;tar&quot;,    &quot;build_hash&quot; : &quot;81a1e9eda8e6183f5237786246f6dced26a10eaf&quot;,    &quot;build_date&quot; : &quot;2020-05-12T02:01:37.602180Z&quot;,    &quot;build_snapshot&quot; : false,    &quot;lucene_version&quot; : &quot;8.5.1&quot;,    &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;,    &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot;  },  &quot;tagline&quot; : &quot;You Know, for Search&quot;}</code></pre><h2 id="安装Kibana"><a href="#安装Kibana" class="headerlink" title="安装Kibana"></a>安装Kibana</h2><p>其实，要想使用Elasticsearch，不一定要安装Kibana。但有了Kibana，可以实现对Elasticsearch中的数据可视化。</p><p>从官网下载：<a href="https://www.elastic.co/cn/downloads/kibana" rel="external nofollow noopener noreferrer" target="_blank">https://www.elastic.co/cn/downloads/kibana</a></p><p>解压缩后进入config目录并修改kibana.yml:</p><pre><code>server.host: &quot;0.0.0.0&quot;</code></pre><p>进入bin目录运行：</p><pre><code>./kibana</code></pre><p>可以看到如下界面：    </p><p><img src="/images/blockchain/hive/es2.png" alt="Elasticsearch"></p><p>导入如下电商数据进行测试：</p><p><img src="/images/blockchain/hive/es3.png" alt="Elasticsearch"></p><p>打开devtool后进行一个简单的查询，可以看到如下数据：</p><p><img src="/images/blockchain/hive/es4.png" alt="Elasticsearch"></p><h2 id="Elasticsearch中的重要概念"><a href="#Elasticsearch中的重要概念" class="headerlink" title="Elasticsearch中的重要概念"></a>Elasticsearch中的重要概念</h2><p>在向ElasticSearch中插入数据之前，把其中的重要概念和传统的关系型数据库做一个对比：</p><p><strong>ES =&gt; RDB</strong></p><p>Index  =&gt;  Database<br>Type  =&gt;   Table<br>Document  =&gt;  Row<br>Field =&gt;  Column<br>Mapping  =&gt;   Schema</p><h2 id="安装并测试Python-elasticsearch模块"><a href="#安装并测试Python-elasticsearch模块" class="headerlink" title="安装并测试Python elasticsearch模块"></a>安装并测试Python elasticsearch模块</h2><p>首先安装elasticsearch模块：</p><pre><code>pip install elasticsearch</code></pre><p>进入Python命令行，依次输入如下命令创建一个新的索引“hive-posts-index”：</p><pre><code>&gt;&gt;&gt; from datetime import datetime&gt;&gt;&gt; from elasticsearch import Elasticsearch&gt;&gt;&gt; es = Elasticsearch()&gt;&gt;&gt; es.indices.create(index=&apos;hive-posts-index&apos;, ignore=400){&apos;acknowledged&apos;: True, &apos;shards_acknowledged&apos;: True, &apos;index&apos;: &apos;hive-posts-index&apos;}</code></pre><p>如果要删除记录：</p><pre><code>curl -X DELETE &apos;localhost:9200/test-index&apos;</code></pre><p>进入Kibana devtool界面，就会看到这个索引已经创建：</p><p><img src="/images/blockchain/hive/es5.png" alt="Elasticsearch"></p><p>测试添加记录</p><pre><code>es.index(index=&quot;hive-posts-index&quot;, id=1, body={&quot;any&quot;: &quot;data&quot;, &quot;timestamp&quot;: datetime.now()})</code></pre><p>读取记录：</p><pre><code>&gt;&gt;&gt; es.get(index=&quot;hive-posts-index&quot;, id=1){&apos;_index&apos;: &apos;hive-posts-index&apos;, &apos;_type&apos;: &apos;_doc&apos;, &apos;_id&apos;: &apos;1&apos;, &apos;_version&apos;: 1, &apos;_seq_no&apos;: 0, &apos;_primary_term&apos;: 1, &apos;found&apos;: True, &apos;_source&apos;: {&apos;any&apos;: &apos;data&apos;, &apos;timestamp&apos;: &apos;2020-06-02T15:52:40.759337&apos;}}</code></pre><h2 id="将Hive中的帖子插入到Elasticsearch中"><a href="#将Hive中的帖子插入到Elasticsearch中" class="headerlink" title="将Hive中的帖子插入到Elasticsearch中"></a>将Hive中的帖子插入到Elasticsearch中</h2><p>写了一个简单的程序，将我最新5篇文章的标题，正文，分类保存到ES，并以permlink作为ES中的id：</p><pre><code>from beem import Steemfrom beem.account import Accountfrom datetime import datetimefrom elasticsearch import Elasticsearches = Elasticsearch()hive    = Steem(nodes = &apos;https://api.hive.blog&apos;)account = Account(&apos;aafeng&apos;, steem_instance = hive)posts   = account.get_blog(start_entry_id=0, limit=5)for post in posts:    author   = post.author    title    = post.title    body     = post.body    category = post.category    permlink = post.permlink    es.index(index=&quot;hive-posts-index&quot;, id=permlink, body={&quot;author&quot;: author,\                                                    &quot;title&quot;:  title,\                                                    &quot;body&quot;:   body,\                                                    &quot;category&quot;: category,\                                                    &quot;permlink&quot;: permlink,\                                                    &quot;timestamp&quot;: datetime.now()})</code></pre><p>在Kibana中进行查询：</p><pre><code>GET hive-posts-index/_search?q=*:*</code></pre><p>从输出可以看出，我的文章已经保存到ES中了:</p><p><img src="/images/blockchain/hive/es6.png" alt="Elasticsearch"></p><p>也可以使用curl验证是否已经将数据保存至ES：</p><pre><code>curl http://localhost:9200/hive-posts-index/_search?size=5</code></pre><p>然后可以使用ES来进行各种查询了，比如：</p><pre><code>GET hive-posts-index/_search?q=title:必有GET hive-posts-index/_search?q=category:hive-105017</code></pre><p>查看所有索引：</p><pre><code>GET _cat/indicesGET _cat/indices?v</code></pre><p>查看一个文档：</p><pre><code>GET hive-posts-index/_doc/6ulbjb</code></pre><p>显示所有Type:</p><pre><code>GET _mapping?pretty=true</code></pre>]]></content>
    
    <summary type="html">
    
      将Hive文章保存到Elasticsearch的尝试
    
    </summary>
    
      <category term="区块链" scheme="https://www.aafeng.uk/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="Hive" scheme="https://www.aafeng.uk/tags/Hive/"/>
    
  </entry>
  
  <entry>
    <title>疫情这个怪兽正在慢慢吞噬着我们的生活</title>
    <link href="https://www.aafeng.uk/covid19-impacts/"/>
    <id>https://www.aafeng.uk/covid19-impacts/</id>
    <published>2020-06-03T23:06:22.253Z</published>
    <updated>2020-06-03T23:06:22.253Z</updated>
    
    <content type="html"><![CDATA[<p>今天听到一个让人非常遗憾的消息，位于约克的英国千年古校York Minster School由于缺少资金，被迫关闭。校中学生部分转到另一所私校，部分自己需要找下一家。</p><p><img src="/images/life/covid19/impact1.jpg" alt="疫情"></p><a id="more"></a><p>这座古校建于公元627年，由于依附于约克大教堂，因此该校的唱诗班以至音乐都非常强。而且这座学校还是英国著名的prep school，为英国很多的顶级私立学校输送了众多优秀的学生。最近由于封城，约克的旅游业遭受了致命性打击，而作为约克最著名的景点之一，约克大教堂也遭受了重创。关闭Minster School也是在当前疫情下的无奈之举。</p><p>很不幸的是，在同一天听到了另一个坏消息。由于游客锐减为零，英国乃至欧洲最大的动物园之一Chester Zoo也面临闭园的厄运。去年年底还曾经去Chester动物园玩过，没有想到目前会是这样一个局面。目前动物园在官网呼吁大家的帮助，以渡过难关：</p><p><img src="/images/life/covid19/zoo1.png" alt="疫情"></p><p>可以选择在线捐款，也可以选择“收养”一个动物。如果选择“收养”，动物园还会照看动物，只不过你的名字会被打印出来，并会陈列在动物名牌旁边的致谢列表中。看看这些可爱的动物吧，要不要收养一只？</p><p><img src="/images/life/covid19/zoo2.jpg" alt="疫情"></p><p><img src="/images/life/covid19/zoo3.jpg" alt="疫情"></p><p><img src="/images/life/covid19/zoo4.jpg" alt="疫情"></p><p>最近听到的类似信息有很多。可以看到，疫情对人们生活的负面影响已经慢慢的显现出来了。接下来可能还会有更多的公司倒闭，就连英国的很多大学也会收到重大影响，毕竟海外学生的学费是很多大学的重要收入来源。在这种形式下，只能是大家互相帮助，共度时艰。希望学校能够早日复课，动物园能够重新开放，我们的生活也能早日恢复正常。</p>]]></content>
    
    <summary type="html">
    
      疫情这个怪兽正在慢慢吞噬着我们的生活
    
    </summary>
    
      <category term="生活" scheme="https://www.aafeng.uk/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="疫情" scheme="https://www.aafeng.uk/tags/%E7%96%AB%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>How to save Hive posts into Elasticsearch</title>
    <link href="https://www.aafeng.uk/hive-elasticserach-tutorial/"/>
    <id>https://www.aafeng.uk/hive-elasticserach-tutorial/</id>
    <published>2020-06-03T14:25:34.616Z</published>
    <updated>2020-06-03T14:25:34.616Z</updated>
    
    <content type="html"><![CDATA[<p>Elasticsearch is a great search engine providing a distributed, multitenant-capable full-text search engine. It provides features like facets, keyword highlighting etc in the search user interface. Here is a tutorial to index Hive posts into elasticsearch.</p><p><img src="/images/blockchain/hive/es.png" alt="Elasticsearch"></p><a id="more"></a><h2 id="Install-Elasticsearch"><a href="#Install-Elasticsearch" class="headerlink" title="Install Elasticsearch"></a>Install Elasticsearch</h2><p>Download Elasticsearch(ES) from the official site:</p><p><a href="https://www.elastic.co/cn/downloads/elasticsearch" rel="external nofollow noopener noreferrer" target="_blank">https://www.elastic.co/cn/downloads/elasticsearch</a></p><p>Decompress:</p><pre><code>tar xvf elasticsearch-7.7.0-linux-x86_64.tar.gz</code></pre><p>Then run the following command to start ES:</p><pre><code>cd elasticsearch-7.7.0/bin ./elasticsearch</code></pre><p>Use curl to test:</p><pre><code>curl localhost:9200</code></pre><p>You will the the output like:</p><pre><code>{  &quot;name&quot; : &quot;YOUR_SERVER_NAME&quot;,  &quot;cluster_name&quot; : &quot;elasticsearch&quot;,  &quot;cluster_uuid&quot; : &quot;liHA066AQJeE91lv8lLqig&quot;,  &quot;version&quot; : {    &quot;number&quot; : &quot;7.7.0&quot;,    &quot;build_flavor&quot; : &quot;default&quot;,    &quot;build_type&quot; : &quot;tar&quot;,    &quot;build_hash&quot; : &quot;81a1e9eda8e6183f5237786246f6dced26a10eaf&quot;,    &quot;build_date&quot; : &quot;2020-05-12T02:01:37.602180Z&quot;,    &quot;build_snapshot&quot; : false,    &quot;lucene_version&quot; : &quot;8.5.1&quot;,    &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;,    &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot;  },  &quot;tagline&quot; : &quot;You Know, for Search&quot;}</code></pre><h2 id="Install-Kibana"><a href="#Install-Kibana" class="headerlink" title="Install Kibana"></a>Install Kibana</h2><p>You don’t have to install Kibana prior to using ES. However, Kibana provides lots of additional features to your data.</p><p>Download from: <a href="https://www.elastic.co/cn/downloads/kibana" rel="external nofollow noopener noreferrer" target="_blank">https://www.elastic.co/cn/downloads/kibana</a></p><p>Decompress and modify file: config/kibana.yml, add this line:</p><pre><code>server.host: &quot;0.0.0.0&quot;</code></pre><p>Run Kibana</p><pre><code>cd bin./kibana</code></pre><p>You will see the following UI</p><p><img src="/images/blockchain/hive/es2.png" alt="Elasticsearch"></p><p>Import the E Commerence data for testing:</p><p><img src="/images/blockchain/hive/es3.png" alt="Elasticsearch"></p><p>Open the evtool and run a simple query, you will see:</p><p><img src="/images/blockchain/hive/es4.png" alt="Elasticsearch"></p><h2 id="Important-concepts-in-ES"><a href="#Important-concepts-in-ES" class="headerlink" title="Important concepts in ES"></a>Important concepts in ES</h2><p>Let’s compare the terms in ES with relational database:</p><p><strong>ES              RDB</strong></p><p>Index  =&gt;  Database<br>Type  =&gt;   Table<br>Document  =&gt;  Row<br>Field =&gt;  Column<br>Mapping  =&gt;   Schema</p><h2 id="Install-and-test-Python-elasticsearch-module"><a href="#Install-and-test-Python-elasticsearch-module" class="headerlink" title="Install and test Python elasticsearch module"></a>Install and test Python elasticsearch module</h2><p>Install elasticsearch via pip:</p><pre><code>pip install elasticsearch</code></pre><p>Enter Python interactive mode, and run the following commands to create ES index called “hive-posts-index”:</p><pre><code>&gt;&gt;&gt; from datetime import datetime&gt;&gt;&gt; from elasticsearch import Elasticsearch&gt;&gt;&gt; es = Elasticsearch()&gt;&gt;&gt; es.indices.create(index=&apos;hive-posts-index&apos;, ignore=400){&apos;acknowledged&apos;: True, &apos;shards_acknowledged&apos;: True, &apos;index&apos;: &apos;hive-posts-index&apos;}</code></pre><p>As shown in Kibana devtool, the ES index has been created:</p><p><img src="/images/blockchain/hive/es5.png" alt="Elasticsearch"></p><p>Add a test document into your index:</p><pre><code>es.index(index=&quot;hive-posts-index&quot;, id=1, body={&quot;any&quot;: &quot;data&quot;, &quot;timestamp&quot;: datetime.now()})</code></pre><p>Read the document you just added from ES:</p><pre><code>&gt;&gt;&gt; es.get(index=&quot;hive-posts-index&quot;, id=1){&apos;_index&apos;: &apos;hive-posts-index&apos;, &apos;_type&apos;: &apos;_doc&apos;, &apos;_id&apos;: &apos;1&apos;, &apos;_version&apos;: 1, &apos;_seq_no&apos;: 0, &apos;_primary_term&apos;: 1, &apos;found&apos;: True, &apos;_source&apos;: {&apos;any&apos;: &apos;data&apos;, &apos;timestamp&apos;: &apos;2020-06-02T15:52:40.759337&apos;}}</code></pre><h2 id="Add-Hive-posts-into-ES-index"><a href="#Add-Hive-posts-into-ES-index" class="headerlink" title="Add Hive posts into ES index"></a>Add Hive posts into ES index</h2><p>Here is a demo script to add my latest 5 posts into ES index:</p><pre><code>from beem import Steemfrom beem.account import Accountfrom datetime import datetimefrom elasticsearch import Elasticsearches = Elasticsearch()hive    = Steem(nodes = &apos;https://api.hive.blog&apos;)account = Account(&apos;aafeng&apos;, steem_instance = hive)posts   = account.get_blog(start_entry_id=0, limit=5)for post in posts:    author   = post.author    title    = post.title    body     = post.body    category = post.category    permlink = post.permlink    es.index(index=&quot;hive-posts-index&quot;, id=permlink, body={&quot;author&quot;: author,\                                                    &quot;title&quot;:  title,\                                                    &quot;body&quot;:   body,\                                                    &quot;category&quot;: category,\                                                    &quot;permlink&quot;: permlink,\                                                    &quot;timestamp&quot;: datetime.now()})</code></pre><p>We can query it in Kibana:</p><pre><code>GET hive-posts-index/_search?q=*:*</code></pre><p>The output suggests that my posts have been stored in ES:</p><p><img src="/images/blockchain/hive/es6.png" alt="Elasticsearch"></p><p>We also can use curl to test if my posts have been saved into ES:</p><pre><code>curl http://localhost:9200/hive-posts-index/_search\?size=5</code></pre><p>Now we have flexi way to query post data:</p><pre><code>GET hive-posts-index/_search?q=body:elasticsearchGET hive-posts-index/_search?q=category:hive-105017</code></pre>]]></content>
    
    <summary type="html">
    
      How to save Hive posts into Elasticsearch
    
    </summary>
    
      <category term="英文教程" scheme="https://www.aafeng.uk/categories/%E8%8B%B1%E6%96%87%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Hive" scheme="https://www.aafeng.uk/tags/Hive/"/>
    
  </entry>
  
  <entry>
    <title>房子扩建工程即将开始</title>
    <link href="https://www.aafeng.uk/house-extension/"/>
    <id>https://www.aafeng.uk/house-extension/</id>
    <published>2020-06-02T22:08:19.446Z</published>
    <updated>2020-06-02T22:08:19.446Z</updated>
    
    <content type="html"><![CDATA[<p>家中的房子扩建工程已经酝酿了很长时间。前一段时间由于全面停工停学，建筑工人也都被迫在家休息，因此工程就被拖了下来。今天Builder打电话说再过两周就来家中开始干活了。让我感觉似乎还没有准备好。</p><p><img src="/images/life/builder.jpg" alt="扩建工程"></p><a id="more"></a><p>去年的时候我和媳妇就扩建这件事已经达成一致意见，今年四月份开工，预计2-3个月的时间，在暑假完工，正好趁着暑期把家中收拾好。谁想到整个计划被新冠病毒彻底打乱。现在Builder要求开工，我其实还是非常犹豫的。</p><p>如果现在开工，最坏的可能就是工程干到一半的时候疫情第二次爆发，会被迫停工。这样自己家将会长期成为一个工地，对生活的负面影响将会很大。</p><p>如果现在不开工，而是等待形式彻底明朗的时候再开工。问题就在于第一不知道什么时候形式会变得明朗，甚至不知道形式会不会变得明朗。第二是builder不会一直等我们，可能builder会去做别的工程。再过几个月就到冬季了，而冬季是不适合这种工程的。这样一拖就不知道何年何月才能再重新开工了。</p><p>好在我们选择的Builder是朋友推荐的，人非常好。总是在安慰我们，即使在当前疫情下，我们可以work together，想办法把工程按时完成。</p><p>在反复权衡之后，我们决定开工！就算疫情一时半会不会完全好转，但生活毕竟还要继续。人类可能要学会长期和病毒共存了。至于下一步如何，只能走一步看一步了。希望builder能够顺利把我们的工程做完吧。</p>]]></content>
    
    <summary type="html">
    
      房子扩建工程即将开始
    
    </summary>
    
      <category term="生活" scheme="https://www.aafeng.uk/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>改良版鱼香肉丝</title>
    <link href="https://www.aafeng.uk/shredded-pork/"/>
    <id>https://www.aafeng.uk/shredded-pork/</id>
    <published>2020-06-01T21:19:34.552Z</published>
    <updated>2020-06-01T21:19:34.552Z</updated>
    
    <content type="html"><![CDATA[<p>最近朋友圈很多人都喜欢上了王刚的家常菜食谱。我们照着做了两个菜，感觉效果还真的不错。整体思路是按照王刚的做法来的，但稍微做了些调整，一是因为有的食材家中没有，还有就是完全按照菜谱做的效果并不是很好，最后出锅前又添了些配料。下面记录一下我们自己的改良版鱼香肉丝。</p><p>首先上一个成品图：<br><img src="/images/food/yxrs/1.jpg" alt="鱼香肉丝"></p><a id="more"></a><p>切好肉丝，用一个蛋清，盐，胡椒粉，生抽，料酒腌制肉丝：</p><p><img src="/images/food/yxrs/2.jpg" alt="鱼香肉丝"></p><p>接下来准备姜末，蒜末，还有泡椒碎。我们只用了4个小泡椒，就已经很辣了。由于考虑到孩子要吃，因此把泡椒碎和姜蒜分开放：</p><p><img src="/images/food/yxrs/3.jpg" alt="鱼香肉丝"></p><p>切好配菜，包括青椒丝，胡萝卜丝，和木耳</p><p><img src="/images/food/yxrs/4.jpg" alt="鱼香肉丝"></p><p>用生抽，醋，糖，盐，料酒，水淀粉配酱汁。</p><p>接下来就可以开始炒了。</p><p>首先将腌制好的肉丝在热油中炒熟，盛出备用。</p><p>加下来将姜末，蒜末，和剁椒碎在油中炒香。在这里我们又额外的添加了一勺郫县豆瓣酱，事实证明最终的效果还是很好的。</p><p>将肉丝和配菜放入锅中翻炒。稍后将配好的酱汁放入锅中继续炒熟，撒上葱花即可。</p>]]></content>
    
    <summary type="html">
    
      改良版鱼香肉丝
    
    </summary>
    
      <category term="美食" scheme="https://www.aafeng.uk/categories/%E7%BE%8E%E9%A3%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>Python中的列表生成式</title>
    <link href="https://www.aafeng.uk/python-list-comprehensions/"/>
    <id>https://www.aafeng.uk/python-list-comprehensions/</id>
    <published>2020-05-31T21:47:23.417Z</published>
    <updated>2020-05-31T21:47:23.417Z</updated>
    
    <content type="html"><![CDATA[<p>用过Python的人一定对它的列表生成式(List Comprehensions)印象非常深刻。刚接触列表生成式的时候可能会有点懵，但一旦适应了之后肯定会喜欢其简洁高效的语法。下面把我经常使用的列表生成式做一个总结，欢迎指正。</p><p><img src="/images/technology/python/python3.png" alt="Python"></p><a id="more"></a><h2 id="数据再运算"><a href="#数据再运算" class="headerlink" title="数据再运算"></a>数据再运算</h2><pre><code>a = range(0, 10)b = [x * 2 for x in a]</code></pre><p>其运算结果会返回一个新的列表</p><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><pre><code>r = range(0, 10)  s = [str(x) for x in a]</code></pre><h2 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h2><pre><code>[a + b for a in &apos;ABC&apos; for b in &apos;123&apos;] </code></pre><p>其输出为：</p><pre><code>[&apos;A1&apos;, &apos;A2&apos;, &apos;A3&apos;, &apos;B1&apos;, &apos;B2&apos;, &apos;B3&apos;, &apos;C1&apos;, &apos;C2&apos;, &apos;C3&apos;]</code></pre><h2 id="使用if做筛选"><a href="#使用if做筛选" class="headerlink" title="使用if做筛选"></a>使用if做筛选</h2><pre><code>b = [x*2 for x in a if x%2==0]</code></pre><p>把赋值与筛选写在一起：</p><pre><code>b = [x*2 for x in range(1, 10) if x%2==0]</code></pre><h2 id="打印键值对"><a href="#打印键值对" class="headerlink" title="打印键值对"></a>打印键值对</h2><p>遍历Python字典，并以自定义方式打印字典中的键值对：</p><pre><code>downloads = {&apos;Jan&apos;: 250, &apos;Feb&apos;: 382, &apos;Mar&apos;: 422}[k+&apos;=&apos; + str(v) for k,v in downloads.items()]</code></pre><h2 id="针对文件系统使用列表生成式"><a href="#针对文件系统使用列表生成式" class="headerlink" title="针对文件系统使用列表生成式"></a>针对文件系统使用列表生成式</h2><p>一条语句列举出”/var/log”中所有以”log”为扩展名的文件：</p><pre><code>[f for f in os.listdir(&quot;/var/log&quot;) if f.endswith(&apos;.log&apos;)]</code></pre><h2 id="函数分组"><a href="#函数分组" class="headerlink" title="函数分组"></a>函数分组</h2><p>在列表生成式中，可以根据函数的返回值进行分组。比如：根据首字母是否为“c“对一个列表中的所有单词进行分组：</p><pre><code>def group_by(lst, fn):    return [        [x for x in lst if fn(x)],        [x for x in lst if not fn(x)]    ]group_by([&apos;fox&apos;, &apos;dog&apos;, &apos;cat&apos;, &apos;people&apos;, &apos;cow&apos;, &apos;chicken&apos;], lambda x: x[0] == &apos;c&apos;)</code></pre><p>其输出为：</p><pre><code>[[&apos;cat&apos;, &apos;cow&apos;, &apos;chicken&apos;], [&apos;fox&apos;, &apos;dog&apos;, &apos;people&apos;]]</code></pre>]]></content>
    
    <summary type="html">
    
      Python中的列表生成式
    
    </summary>
    
      <category term="技术" scheme="https://www.aafeng.uk/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Python" scheme="https://www.aafeng.uk/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>因果关系</title>
    <link href="https://www.aafeng.uk/causal/"/>
    <id>https://www.aafeng.uk/causal/</id>
    <published>2020-05-30T22:11:10.359Z</published>
    <updated>2020-05-30T22:11:10.359Z</updated>
    
    <content type="html"><![CDATA[<p>前两天在写自己DIY那篇文章的时候，对于事情的因果关系，感觉有些困惑。我是因为不擅长DIY而对它没有太大兴趣呢，还是因为对它没有兴趣而变得不是很擅长呢？</p><p><img src="/images/thinking/why.jpg" alt="因果关系"><br>图源：Pixabay</p><a id="more"></a><p>从小接受的教育就是“种瓜得瓜，种豆得豆”，“一分辛苦，一分收获”。在数学上更是相信充分条件所体现的逻辑，比如：如果条件A满足，必然会有结果B。但最近我的想法在发生变化。很多事情的因果关系并不是绝对的。有时候因果关系是可以互换的。</p><p>首先拿我家孩子练琴的事来举例。刚开始的时候，儿子并不喜欢弹琴，但在妈妈的<del>威逼</del>鼓励下，慢慢取得了一些成就，获得很多奖杯/奖牌，同时也得到了老师和同学们的认可。这样他的信心越来越足，也越来越喜欢。在学琴这件事情上，喜欢弹琴和取得成绩之间是什么样的因果关系呢？在我看来，只有喜欢弹琴，才能越弹越好，才能取得好成绩。同样因为取得了好成绩，有了动力，会越来越喜欢弹琴。如果深究下去，终会陷入先有鸡，还是先有蛋的逻辑之中。</p><p>在工作问题上，很多人都会说，要选择一份自己喜欢的工作，这样才会把工作做好，就是所谓的“爱一行，干一行”吧。可我在读书期间，导师曾经说过一句话：”Do it, then like it”。如果用中文表述，应该是：“干一行，爱一行”吧。只要认真做一件工作，慢慢的就会培养对工作的自信，同时也会慢慢真正的喜欢上工作本身。</p><p>曾经听过一个说法：每天早上亲吻自己伴侣的人，收入会比没有这种亲密表现的人高出20%甚至更多，同时他们的平均寿命也更长。想想似乎有道理，早上一个吻，能够增进夫妻感情，精神状态会比较好。这样在工作的时候能做得更好，从而升职加薪。长期保持好的心理状态，就能增长寿命。但反过来一想，收入更高的人似乎更有时间来维护夫妻之间的感情。那么这里哪个是因，哪个又是果呢？</p><p>不过，无论怎么讲，每天不要忘记给TA一个吻，好处似乎还真不少。。。</p>]]></content>
    
    <summary type="html">
    
      因果关系
    
    </summary>
    
      <category term="思考" scheme="https://www.aafeng.uk/categories/%E6%80%9D%E8%80%83/"/>
    
    
  </entry>
  
  <entry>
    <title>Python中的日期/时间处理</title>
    <link href="https://www.aafeng.uk/python-datetime/"/>
    <id>https://www.aafeng.uk/python-datetime/</id>
    <published>2020-05-29T22:21:38.997Z</published>
    <updated>2020-05-29T22:21:38.997Z</updated>
    
    <content type="html"><![CDATA[<p>在写代码的时候有很多场合需要处理日期和时间，比如：在日志中需要记录当前时间，在处理订单的时候需要处理用户下单的时间，在Hive上的各种点赞机器人需要知道新帖子的创建时间，以及帖子的“年龄”等等。。。在Python中提供了非常强大的日期/时间处理模块：time，和datetime。这些模块中又有很多有用的函数。下面把我经常使用的函数做一总结，欢迎大家指正。</p><p><img src="/images/technology/python/datetime/datetime.jpg" alt="Python中的日期/时间处理"></p><p>图源：pixabay</p><a id="more"></a><h2 id="time模块"><a href="#time模块" class="headerlink" title="time模块"></a>time模块</h2><p>time模块提供了和时间相关的一些类及函数。</p><h3 id="时间偏移量表示法"><a href="#时间偏移量表示法" class="headerlink" title="时间偏移量表示法"></a>时间偏移量表示法</h3><p>在Python交互式窗口中输入time.time()，其输出为一个数字：</p><p><img src="/images/technology/python/datetime/1.png" alt="Python中的日期/时间处理"></p><p>这个数字代表了从1970年1月1日00:00:00至今的秒偏移量。</p><p>将其转换为字符串格式：</p><p><img src="/images/technology/python/datetime/2.png" alt="Python中的日期/时间处理"></p><h3 id="元组表示法"><a href="#元组表示法" class="headerlink" title="元组表示法"></a>元组表示法</h3><p>还有一种时间的表示法：使用包含9个整数的元组分别表示年，月，日，时，分，秒等：</p><p><img src="/images/technology/python/datetime/3.png" alt="Python中的日期/时间处理"></p><p>可以把这个元组转换为第一种表示法：</p><p><img src="/images/technology/python/datetime/4.png" alt="Python中的日期/时间处理"></p><h3 id="格式化字符串表示法"><a href="#格式化字符串表示法" class="headerlink" title="格式化字符串表示法"></a>格式化字符串表示法</h3><p>还可以将时间表示为我们熟悉的格式：</p><p><img src="/images/technology/python/datetime/5.png" alt="Python中的日期/时间处理"></p><h3 id="时间的加减法"><a href="#时间的加减法" class="headerlink" title="时间的加减法"></a>时间的加减法</h3><p>比如，计算一个小时之后的时间：</p><p><img src="/images/technology/python/datetime/6.png" alt="Python中的日期/时间处理"></p><h2 id="datetime模块"><a href="#datetime模块" class="headerlink" title="datetime模块"></a>datetime模块</h2><p>从 datetime 模块中，依次导入date，datetime，timedelta。</p><pre><code>from datetime import date, datetime, timedelta</code></pre><h3 id="获取日期"><a href="#获取日期" class="headerlink" title="获取日期"></a>获取日期</h3><p>获取当前日期：</p><p><img src="/images/technology/python/datetime/7.png" alt="Python中的日期/时间处理"></p><h3 id="日期时间和字符串转换"><a href="#日期时间和字符串转换" class="headerlink" title="日期时间和字符串转换"></a>日期时间和字符串转换</h3><p>将日期转换为字符串；</p><p><img src="/images/technology/python/datetime/8.png" alt="Python中的日期/时间处理"></p><p>将日期时间字符串转换为日期时间(datetime)类型：</p><p><img src="/images/technology/python/datetime/9.png" alt="Python中的日期/时间处理"></p><h3 id="计算时间差"><a href="#计算时间差" class="headerlink" title="计算时间差"></a>计算时间差</h3><p><img src="/images/technology/python/datetime/10.png" alt="Python中的日期/时间处理"></p><p>获取明天和昨天的时间：</p><p><img src="/images/technology/python/datetime/11.png" alt="Python中的日期/时间处理"></p><p>得到Hive文章的发布时间后，计算从文章发布时间到现在时间的秒数：</p><p><img src="/images/technology/python/datetime/12.png" alt="Python中的日期/时间处理"></p>]]></content>
    
    <summary type="html">
    
      Python中的日期/时间处理
    
    </summary>
    
      <category term="技术" scheme="https://www.aafeng.uk/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Python" scheme="https://www.aafeng.uk/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Hiveonboard</title>
    <link href="https://www.aafeng.uk/hiveonboard/"/>
    <id>https://www.aafeng.uk/hiveonboard/</id>
    <published>2020-05-28T21:05:26.755Z</published>
    <updated>2020-05-28T21:05:26.755Z</updated>
    
    <content type="html"><![CDATA[<p>最近看到了Hiveonboard这个账户创建服务，感觉很有意思，和大家分享一下。其实很多dapp都提供账户创建服务，可以说各有各的特色，有的是免费的，有的是需要收费的。有的可以秒级创建账户，有的则需要等待几天甚至更长时间才行。那么，Hiveonboard有什么特色呢？</p><p><img src="/images/blockchain/hive/hiveonboard.jpg" alt="Hiveonboard"></p><a id="more"></a><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>首先，Hiveonboard提供的是创建账户的<strong>服务</strong>，而不是创建账户的<strong>功能</strong>。很多dapp具有创建Hive账户的<strong>功能</strong>，但Hiveonboard则为其他的dapp提供完整的账户创建服务。这样，其他的dapp就不必重新造轮子，而是专注于其核心功能上了。</p><p><img src="/images/blockchain/hive/hiveonboard2.jpg" alt="Hiveonboard"></p><p>从上图中可以看到，当dapp的用户选择了创建账户时，会被转向到Hiveonboard网站上，在完成了账户创建后，会返回该dapp。</p><h2 id="安全性考虑"><a href="#安全性考虑" class="headerlink" title="安全性考虑"></a>安全性考虑</h2><p>为了避免一些恶意网站的利用这项服务实现钓鱼功能，Hiveonboard实现了一个白名单，只有白名单上的用户才能使用这项服务。如果有新的dapp需要使用这项服务，可以<a href="https://github.com/christianfuerst/hiveonboard/blob/master/src/config/whitelist.json" rel="external nofollow noopener noreferrer" target="_blank">提交一个PR</a></p><h2 id="调试模式"><a href="#调试模式" class="headerlink" title="调试模式"></a>调试模式</h2><p>为了便于dapp测试创建账户的操作，Hiveonboard提供了调试模式，这样在进行测试的时候就不会真正的创建账户，也不会进行手机验证。要使用调试模式，只需要在网址中添加参数：debug_mode=true</p><pre><code>https://hiveonboard.com/create-account?debug_mode=true</code></pre><h2 id="试用Hiveonboard"><a href="#试用Hiveonboard" class="headerlink" title="试用Hiveonboard"></a>试用Hiveonboard</h2><p>自己尝试着从 tipu 网站开始，试用了Hiveonboard的账户创建功能，感觉还是很顺滑的。整个账户创建过程只需要不到2分钟的时间。中间需要验证手机号。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果打算开发一款自己的dapp，但没有时间实现账户创建功能，可以考虑试用Hiveonboard，将其账户创建功能和自己的dapp结合在一起。</p>]]></content>
    
    <summary type="html">
    
      Hiveonboard
    
    </summary>
    
      <category term="区块链" scheme="https://www.aafeng.uk/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="Hive" scheme="https://www.aafeng.uk/tags/Hive/"/>
    
  </entry>
  
  <entry>
    <title>DIY菜鸟</title>
    <link href="https://www.aafeng.uk/diy/"/>
    <id>https://www.aafeng.uk/diy/</id>
    <published>2020-05-27T22:31:36.436Z</published>
    <updated>2020-05-27T22:31:36.436Z</updated>
    
    <content type="html"><![CDATA[<p>今天媳妇告诉我家里的锅炉坏了，水管里没有热水了。于是我去看了一下，发现报警指示灯一直在闪。首先检查了一下水压，发现水压不足。于是立刻把水压调整了一下，但报警灯仍然还亮着。接下来找到了锅炉的说明书，在排错章节找到了这个问题的解决方案。把锅炉重置了一下，问题解决。整个用时不足20分钟。</p><p><img src="/images/life/boiler.jpg" alt="Boiler"></p><a id="more"></a><p>其实，我本是一个DIY菜鸟。原因很简单：第一自己对这类东西不感兴趣，第二在这方面的动手能力似乎不强。久而久之，能够花钱找人的就都尽量找人来解决了。但在英国这里的人工很贵。而且很多电工，水暖工只要一请到家中，无论是否修好都要收费。记得上次家中的下水道堵了，自己尝试了一下无法解决。于是叫了一个水暖工来帮忙。水暖工来干了一个下午都没有疏通，当时感觉一百多英镑可能要白扔了。还好在水暖工打算放弃，要收工的最后一刻，下水终于通了。后来，通过和朋友打听，以及网上搜到的资料，学会了定期向下水道中灌些碱性的Soda Crystal来溶解其中的油脂。同时也购买了相应的工具。慢慢的掌握了保持下水道畅通的诀窍。</p><p>后来慢慢的接触到了很多DIY大神。记得当时读书的时候，自己的导师是计算机科学的教授，同时也是一位DIY高手。他在业余时间自己组装过摩托车，汽车，甚至花费了几年的时间自己组装了一艘游艇，而且第一次下水试航就成功！后来周边也有很多朋友是DIY高手，自己重做浴室，重新装修厨房，把电工，水暖工，瓦工的活全包了。慢慢受这些高人们的影响。有些家中的电器或者设备出现故障，首先就会想到自己能不能修好。自己对着Youtube视频，磕磕绊绊的也修过不少东西，慢慢也对DIY产生了一点点兴趣。</p><p>中国有句古话叫做庖丁解牛，其实很多事情都是这样的，练久了就成了高手和专家。我不能奢望自己能成为DIY高手，但对着Youtube视频，把家中电器，设备的常见故障已经解决了不少了，应该也算是半个DIY爱好者了吧。</p>]]></content>
    
    <summary type="html">
    
      DIY菜鸟
    
    </summary>
    
      <category term="生活" scheme="https://www.aafeng.uk/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="DIY" scheme="https://www.aafeng.uk/tags/DIY/"/>
    
  </entry>
  
  <entry>
    <title>体验了一下Python数据可视化神器pyecharts</title>
    <link href="https://www.aafeng.uk/pyecharts/"/>
    <id>https://www.aafeng.uk/pyecharts/</id>
    <published>2020-05-27T15:48:38.739Z</published>
    <updated>2020-05-27T15:48:38.739Z</updated>
    
    <content type="html"><![CDATA[<p>最近试用了一个由百度开源的数据可视化Python软件包<a href="https://github.com/pyecharts/pyecharts" rel="external nofollow noopener noreferrer" target="_blank">pyecharts</a>。它将Python和<a href="https://echarts.apache.org/en/index.html" rel="external nofollow noopener noreferrer" target="_blank">echarts</a>结合在一起，提供强大的数据可视化支持，感觉非常好用。向大家强烈推荐。</p><p><img src="/images/technology/python/pyecharts/pyecharts.png" alt="pyecharts"></p><a id="more"></a><p>首先看下其官方的介绍：</p><blockquote><ul><li>简洁的 API 设计，使用如丝滑般流畅，支持链式调用</li><li>囊括了 30+ 种常见图表，应有尽有</li><li>支持主流 Notebook 环境，Jupyter Notebook 和 JupyterLab</li><li>可轻松集成至 Flask，Sanic，Django 等主流 Web 框架</li><li>高度灵活的配置项，可轻松搭配出精美的图表</li><li>详细的文档和示例，帮助开发者更快的上手项目</li><li>多达 400+ 地图文件，并且支持原生百度地图，为地理数据可视化提供强有力的支持</li></ul></blockquote><p>对我而言，比较吸引我的特点包括：简洁的API设计，支持各种常见图表，和Jupyter Notebook的集成，以及丰富的文档。</p><p>其安装非常简单，只需要运行：</p><pre><code>pip install pyecharts</code></pre><h2 id="生成渲染后的HTML页面"><a href="#生成渲染后的HTML页面" class="headerlink" title="生成渲染后的HTML页面"></a>生成渲染后的HTML页面</h2><p>如下代码会生产一个简单的柱状图：</p><pre><code>from pyecharts.charts import Barfrom pyecharts import options as optsbar = (    Bar()    .add_xaxis([&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;June&quot;])    .add_yaxis(&quot;Downloads&quot;, [114, 155, 97, 131, 185, 270])    .set_global_opts(title_opts=opts.TitleOpts(title=&quot;Downloads&quot;)))bar.render()</code></pre><p>上面代码会在当前目录下生成一个文件：render.html，该文件会显示如下的柱状图：</p><p><img src="/images/technology/python/pyecharts/pyecharts2.png" alt="pyecharts"></p><h2 id="在Jupyter-notebook中使用"><a href="#在Jupyter-notebook中使用" class="headerlink" title="在Jupyter_notebook中使用"></a>在Jupyter_notebook中使用</h2><p>和前面的代码一样，只不过在最后需要调用：</p><pre><code>bar.render_notebook()</code></pre><p><img src="/images/technology/python/pyecharts/pyecharts3.png" alt="pyecharts"></p><h2 id="生成渲染后图片"><a href="#生成渲染后图片" class="headerlink" title="生成渲染后图片"></a>生成渲染后图片</h2><p>首先安装snapshot_selenium：</p><pre><code>pip install snapshot_selenium</code></pre><p>还需要安装Chrome。 切换到root用户运行：</p><pre><code>curl -sS -o - https://dl-ssl.google.com/linux/linux_signing_key.pub | apt-key addecho &quot;deb [arch=amd64]  http://dl.google.com/linux/chrome/deb/ stable main&quot; &gt;&gt; /etc/apt/sources.list.d/google-chrome.listapt-get -y updateapt-get -y install google-chrome-stable</code></pre><p>运行如下代码就可以在当前目录下生成一个PNG图片：</p><pre><code>from pyecharts.charts import Barfrom pyecharts import options as optsfrom pyecharts.render import make_snapshotfrom snapshot_selenium import snapshot as driverbar = (    Bar()    .add_xaxis([&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;June&quot;])    .add_yaxis(&quot;Downloads&quot;, [114, 155, 97, 131, 185, 270])    .set_global_opts(title_opts=opts.TitleOpts(title=&quot;Downloads&quot;)))make_snapshot(driver, bar.render(), &quot;bar.png&quot;)</code></pre><p>pyecharts支持的图表超过30种，我仅仅尝试了两种，但感觉其他图表都类似，应该非常容易上手。下一步项目中如果需要的话，应该能够拿起来就用了。</p>]]></content>
    
    <summary type="html">
    
      体验了一下Python数据可视化神器pyecharts
    
    </summary>
    
      <category term="技术" scheme="https://www.aafeng.uk/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Python" scheme="https://www.aafeng.uk/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python学习笔记 - collections</title>
    <link href="https://www.aafeng.uk/python-collections/"/>
    <id>https://www.aafeng.uk/python-collections/</id>
    <published>2020-05-26T14:00:46.461Z</published>
    <updated>2020-05-26T14:00:46.461Z</updated>
    
    <content type="html"><![CDATA[<p>在Python中，除了系统默认的容器：dict, list, set, tuple之外，还有一个非常强大的模块：collections。在这个模块中有很多非常好用的功能，能供简化我们的代码。下面举几个例子，欢迎大家指正。</p><p><img src="/images/technology/python/python3.png" alt="Python"></p><a id="more"></a><h2 id="namedtuple-提高代码可读性"><a href="#namedtuple-提高代码可读性" class="headerlink" title="namedtuple - 提高代码可读性"></a>namedtuple - 提高代码可读性</h2><p>首先来看一个例子：假设我们有一组数据。想用Python对这组数据进行处理。最为直观的做法是：</p><pre><code>people_list = [(&apos;Jim&apos;, &apos;male&apos;, 30), (&apos;Julie&apos;, &apos;female&apos;, 25)]for p in people_list:    print (f&apos;{p[0]} is a {p[2]} year old {p[1]}&apos;)</code></pre><p>但以上代码的最大缺点就是其可读性太差。上面的p[0], p[1], p[2]具体代表什么数据要检查前面的代码才能知道。设想如果处理的数据量更大，比如，共有十几，甚至几十列数据，如果在查看p[35], p[48]之类的代码时肯定会痛苦万分的。</p><p>这个时候就应该考虑使用collections中的namedtuple:</p><pre><code>import collectionsPerson = collections.namedtuple(&apos;Person&apos;, &apos;name gender age&apos;)people_list = [Person(&apos;Jim&apos;, &apos;male&apos;, 30), Person(&apos;Julie&apos;, &apos;female&apos;, 25)]for p in people_list:    print (f&apos;{p.name} is a {p.age} year old {p.gender}&apos;)</code></pre><p> 以上代码的可读性明显增强。不过使用namedtuple的一个缺点(有时也是优点)就是它的属性是只读的。</p><h2 id="Counter-优雅的统计代码"><a href="#Counter-优雅的统计代码" class="headerlink" title="Counter - 优雅的统计代码"></a>Counter - 优雅的统计代码</h2><p>假设我们需要对一个列表进行统计：</p><pre><code>[&apos;red&apos;,&apos;yellow&apos;,&apos;blue&apos;,&apos;red&apos;,&apos;yellow&apos;,&apos;red&apos;,&apos;black&apos;,&apos;white&apos;,&apos;red&apos;]</code></pre><p>我们希望统计每种颜色出现的次数：</p><pre><code>{&apos;red&apos;: 4, &apos;yellow&apos;: 2, &apos;blue&apos;: 1, &apos;black&apos;: 1, &apos;white&apos;: 1}</code></pre><p>如果使用一个循环，则代码显得非常臃肿：</p><pre><code>color_list = [&apos;red&apos;,&apos;yellow&apos;,&apos;blue&apos;,&apos;red&apos;,&apos;yellow&apos;,&apos;red&apos;,&apos;black&apos;,&apos;white&apos;,&apos;red&apos;]stats = {}for i in color_list:    if stats.get(i) is None:        stats[i] = 1    else:        stats[i] += 1ordered_stats = dict(sorted(stats.items(), key=lambda count: count[1], reverse=True))print(ordered_stats)</code></pre><p>但如果使用collections中的Counter的话，代码就显得非常简洁了：</p><pre><code>from collections import Countercolor_list = [&apos;red&apos;,&apos;yellow&apos;,&apos;blue&apos;,&apos;red&apos;,&apos;yellow&apos;,&apos;red&apos;,&apos;black&apos;,&apos;white&apos;,&apos;red&apos;]stats = Counter(color_list).most_common()</code></pre><p>Counter也可以用来统计一段话中每个字符出现的次数。</p><pre><code>from collections import Counters = &apos;The clever fox jumped over the lazy brown dog.&apos;print(Counter(s).most_common())</code></pre><h2 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h2><p>在使用字典时，一般可以使用 ‘dict = {}’对其进行初始化。在后续使用中，可以使用 ‘dict[element] = xx’，但有一个前提就是，element必须是已经存在的，否则就会出错。比如：</p><p><img src="/images/technology/python/dict1.png" alt="Python"></p><p>当然，我们可以在使用前检查某个元素是否存在：</p><pre><code>&apos;julie&apos; in dict.keys()</code></pre><p>但这会使代码显得很臃肿。</p><p>更为简洁的方法就是使用defaultdict，比如：</p><p><img src="/images/technology/python/dict2.png" alt="Python"></p><p>上面介绍了collections模块中的namedtuple, Counter, defaultdict，使用它们可以简化我们的代码，也能增强程序的可读性。</p>]]></content>
    
    <summary type="html">
    
      Python学习笔记 - collections
    
    </summary>
    
      <category term="技术" scheme="https://www.aafeng.uk/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Python" scheme="https://www.aafeng.uk/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>英国小学即将复课</title>
    <link href="https://www.aafeng.uk/back-to-school/"/>
    <id>https://www.aafeng.uk/back-to-school/</id>
    <published>2020-05-25T22:13:06.487Z</published>
    <updated>2020-05-25T22:13:06.487Z</updated>
    
    <content type="html"><![CDATA[<p>英国政府最近宣布，小学Early Years，Year 1，Year 6将于6月1号复课。但并不是强制性的，家长如果觉得想继续在家Home schooling，可以不去学校，不会计入旷课。</p><a id="more"></a><p>和很多朋友以及家长群中的众多家长沟通过后，家长们明显是两个态度。有些家长认为虽然目前英国疫情有所缓解，但还不放心把孩子送回学校。毕竟让孩子们一整天在学校这么小的空间中严格遵循社交隔离，似乎不太可能。而且，如果孩子们被限制到一个特别小的空间中，完全不能和别的小朋友们互动，那在学校该有多么难受？？？况且，如果老师们的精力都用在监督和提醒小朋友们之间的社交隔离，哪里还有精力进行教学？</p><p>另一种意见则认为，孩子们在过去两个月中在家，由家长负责教育，而家长们同时还要工作。很多家长们的心理几乎快要崩溃。听到这个消息后，感觉终于有盼头了。盼着到了6月1号把孩子们送回学校，自己可以专心工作。</p><p>其实，我个人倾向于第一种观点。虽然现在疫情有所好转，但并没有完全消除。现在直接把孩子们送回学校，增加互相接触的机会。万一再引发第二波疫情，后果将不堪设想。况且，经过最近一段时间的在家工作/辅导功课。似乎也没有最初想象中的那么糟糕。尽管工作效率比不上在办公室的时候，但和媳妇分好工，分别在不同时段兼顾孩子。在该工作的时段精力高度集中的工作，感觉也还比较出活。</p><p>最近听一位护士朋友说，英国的各大城市疫情数据都非常看好，但在一些旅游景点的确诊病例却在增加。可见形式还没有那么乐观。我决定先不送孩子自己上学，在家给他们辅导一下，顺便检查一些知识点上的欠缺，似乎比在学校时学到的东西还多。</p><p>不过无论如何，该放松的时候也要放松一下。趁着这两天有风（话说英国的天气，经常妖风肆虐），把从国内拿来的风筝装好了，去家附近的草地上去试玩了一下。英国的风还真的给力，不用任何技巧，我站着不动，风筝自己就飞了起来。你能看到下面图片中的风筝吗？</p><p><img src="/images/life/kite.jpg" alt="Kite"></p><p>照片摄于2020.5，在家附近大草坪上放风筝</p>]]></content>
    
    <summary type="html">
    
      英国小学即将复课
    
    </summary>
    
      <category term="生活" scheme="https://www.aafeng.uk/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="疫情" scheme="https://www.aafeng.uk/tags/%E7%96%AB%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>Jupyter的几个设置</title>
    <link href="https://www.aafeng.uk/jupyter_settings/"/>
    <id>https://www.aafeng.uk/jupyter_settings/</id>
    <published>2020-05-25T11:46:35.598Z</published>
    <updated>2020-05-25T11:46:35.598Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="/jupyter/">前面的文章</a>中介绍了Jupyter，但在进一步的使用中，发现一些需要设置/安装/配置的选项，比如：如何禁用默认的Terminal窗口，如何让多个用户使用Jupyter，如何在Jupyter中使用Turtle画图等。下面总结如下。</p><p><img src="/images/technology/jupyter/jupyter.jpg" alt="Jupyter"></p><a id="more"></a><h2 id="禁用terminal"><a href="#禁用terminal" class="headerlink" title="禁用terminal"></a>禁用terminal</h2><p>在默认情况下，打开Jupyter窗口后，可以新建一个终端窗口。在终端窗口中可以运行各种Linux命令。在终端窗口中使用的是运行Jupyter的用户，因此具有和该用户同样的权限。因此，如果打算和别人分享Jupyter，最好不要用权限过大的用户运行Jupyter，同时应该禁用终端窗口。不过，严格的讲，这并不能阻止恶意用户运行Linux命令，只要能运行Python脚本，就会有多种方式达到这个目的。但系统安全是一个渐进的过程。至少对于不太熟悉Linux的用户，如果一不小心进入终端窗口，再一不小心误删了文件，不也麻烦吗？</p><p><img src="/images/technology/jupyter/terminal1.png" alt="Jupyter"></p><p>要想禁止Linux终端窗口，可以在Jupyter的配置文件(用户根目录下.jupyter/jupyter_notebook_config.py)中添加一行就可以了：</p><pre><code>c.NotebookApp.terminals_enabled = False</code></pre><p>可以看到，终端已经被禁用。</p><p><img src="/images/technology/jupyter/terminal2.png" alt="Jupyter"></p><h2 id="在Jupyter中设定多个账号"><a href="#在Jupyter中设定多个账号" class="headerlink" title="在Jupyter中设定多个账号"></a>在Jupyter中设定多个账号</h2><p>默认的配置文件在/home/USERNAME/.jupyter/jupyter_notebook_config.py中。其初始设置非常简单：</p><pre><code>c.NotebookApp.allow_origin = &apos;*&apos; #allow all originsc.NotebookApp.ip = &apos;0.0.0.0&apos; # listen on all IPs</code></pre><p>如果想要多个用户共同使用Jupyter，可以为这些用户设置不同的端口，密码，和工作目录。比如：可以创建配置文件：/home/USERNAME/.jupyter/user1_config.py:</p><pre><code>c.NotebookApp.allow_origin = &apos;*&apos; c.NotebookApp.ip = &apos;0.0.0.0&apos; c.NotebookApp.terminals_enabled = Falsec.NotebookApp.port = 8890c.NotebookApp.notebook_dir = &apos;/home/user1/jupyter_notes&apos;</code></pre><p>在运行Jupyter的时候指定配置文件：</p><pre><code>jupyter notebook --config /home/user1/.jupyter/user1_config.py</code></pre><p>依次类推，可以为不同用户创建不同的配置文件，这样就可以彼此之间互不干扰了。</p>]]></content>
    
    <summary type="html">
    
      Jupyter的几个设置
    
    </summary>
    
      <category term="技术" scheme="https://www.aafeng.uk/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Python" scheme="https://www.aafeng.uk/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>开始使用Jupyter Notebook</title>
    <link href="https://www.aafeng.uk/jupyter/"/>
    <id>https://www.aafeng.uk/jupyter/</id>
    <published>2020-05-24T09:38:08.775Z</published>
    <updated>2020-05-24T09:38:08.775Z</updated>
    
    <content type="html"><![CDATA[<p>一直听说过Jupyter很好用，但自己并没有试过。最近在教孩子编程的时候正好尝试了一下，感觉确实很好用。它最大的优点就是把代码和程序运行的结果放在了同一个页面中。这样就特别适合初学者，一边学习，一边运行，直接能看到结果。当然，Jupyter的作用远不止这些，比如在Jupyter Notebook中可以添加程序代码，Markdown，方程式，图片等等各种类型的数据。可以用Jupyter来进行数据清理，数据转换，数据可视化，统计建模，机器学习等等。</p><p><img src="/images/technology/jupyter/jupyter.png" alt="Jupyter"></p><a id="more"></a><p>其官方定义如下：</p><blockquote><p>The Jupyter Notebook is an open-source web application that allows you to create and share documents that contain live code, equations, visualizations and narrative text. Uses include: data cleaning and transformation, numerical simulation, statistical modeling, data visualization, machine learning, and much more.</p></blockquote><p>可以把Jupyter安装在本机，然后运行命令：”jupyter notebook”，它就会启动一个Web服务器，默认情况下会监听“8888”端口。</p><p><img src="/images/technology/jupyter/jupyter2.png" alt="Jupyter"></p><p>可以看到，在同一个Web页面中，可以编辑并运行代码，非常方便。这种直观的方式尤其适合初学者，让他们能够把注意力集中到要学习的内容上，而不是编程环境上。</p><p>同时，由于可以把Markdown和代码混排，特别适合老师们准备教案。不仅有文字说明，也有程序代码的源代码和运行结果。</p><p>Jupyter的另一大用途就是数据可视化，把代码和运行结果放在同一个页面，调整代码后，即刻可以看到更新后的图表，非常方便。比如，有人<a href="https://www.kaggle.com/neelkudu28/covid-19-visualizations-predictions-forecasting" rel="external nofollow noopener noreferrer" target="_blank">统计了印度的冠状病毒疫情数据</a>，并做了相应的图表：</p><p><img src="/images/technology/jupyter/jupyter3.png" alt="Jupyter"></p><p>除了自己安装并运行Jupyter服务器之外，也可以使用很多云计算平台的相关服务，比如：</p><ul><li><a href="https://mybinder.org/" rel="external nofollow noopener noreferrer" target="_blank">mybinder</a>: 这个网站可以把你提交到Github的Jupyter Notebook装载并运行，这样别人无需搭建环境，就能看到你Notebook的运行结果。</li><li><a href="https://www.kaggle.com/notebooks" rel="external nofollow noopener noreferrer" target="_blank">kaggle</a>：在这个平台上可以创建自己的Notebook，也可以搜索，使用别人的Notebook。</li><li><a href="https://colab.research.google.com/" rel="external nofollow noopener noreferrer" target="_blank">Google colab</a></li><li><a href="https://www.ibm.com/uk-en/cloud/watson-studio" rel="external nofollow noopener noreferrer" target="_blank">IBM Watson Studio</a></li><li><a href="https://paiza.cloud/en/" rel="external nofollow noopener noreferrer" target="_blank">Paiza Cloud</a></li></ul><p>感觉越来越喜欢这个工具了，打算花点时间进一步探索一下。</p>]]></content>
    
    <summary type="html">
    
      开始使用Jupyter Notebook
    
    </summary>
    
      <category term="技术" scheme="https://www.aafeng.uk/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Python" scheme="https://www.aafeng.uk/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>如何在Jupyter中使用Turtle</title>
    <link href="https://www.aafeng.uk/jupyter-turtle/"/>
    <id>https://www.aafeng.uk/jupyter-turtle/</id>
    <published>2020-05-24T06:23:33.644Z</published>
    <updated>2020-05-24T06:23:33.644Z</updated>
    
    <content type="html"><![CDATA[<p>一直在使用Python Turtle教孩子编程。最近感觉Jupyter特别适合教学，那么怎样在Jupyter中使用Turtle呢？答案是<a href="https://github.com/takluyver/mobilechelonian" rel="external nofollow noopener noreferrer" target="_blank">mobilechelonian</a>。</p><p><img src="/images/technology/jupyter/jupyter.jpg" alt="Jupyter"></p><a id="more"></a><p>首先在Notebook中安装依赖库并进行测试：</p><pre><code>!pip install mobilechelonian!pip install matplotlibimport numpy as npimport matplotlib.pyplot as pltfrom mobilechelonian import Turtlefrom mobilechelonian import prepare_jsprepare_js()</code></pre><p>运行以上代码就会安装mobilechelonian。接下来就可以使用Turtle来画图了：</p><pre><code>from mobilechelonian import Turtlet = Turtle()t.speed(5)t.pencolor(&quot;blue&quot;)for i in range(4):    t.left(90)    t.forward(60)</code></pre><p><img src="/images/technology/jupyter/jupyter-turtle.png" alt="Jupyter"></p>]]></content>
    
    <summary type="html">
    
      如何在Jupyter中使用Turtle
    
    </summary>
    
      <category term="技术" scheme="https://www.aafeng.uk/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Python" scheme="https://www.aafeng.uk/tags/Python/"/>
    
  </entry>
  
</feed>
