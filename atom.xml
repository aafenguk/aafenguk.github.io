<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>aafeng</title>
  <icon>https://www.gravatar.com/avatar/a176a52d9d4ac7d9f90a5204a7d87bcd</icon>
  <subtitle>aafeng&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.aafeng.uk/"/>
  <updated>2021-10-19T22:07:18.186Z</updated>
  <id>https://www.aafeng.uk/</id>
  
  <author>
    <name>aafeng</name>
    <email>aafenguk@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何在Gatsby中实现分页</title>
    <link href="https://www.aafeng.uk/gatsby-pagination/"/>
    <id>https://www.aafeng.uk/gatsby-pagination/</id>
    <published>2021-10-19T22:07:18.186Z</published>
    <updated>2021-10-19T22:07:18.186Z</updated>
    
    <content type="html"><![CDATA[<p>在前面介绍的<a href="/gatsby-page-generation/">Gatsby中的页面生成</a>中，我们已经可以生成category/tag对应的文件。但是当每个category/tag中文章数目较多的时候，肯定就需要分页了。下面介绍一下如何在Gatsby中实现分页控制，从而让Gatsby在生成页面时自动进行分页处理。</p><p><img src="https://user-images.githubusercontent.com/63479035/135064099-e2e1247d-a658-484b-8618-a85bfc56ac7a.png" alt="image"><br>Source: Gatsby官网</p><a id="more"></a><h2 id="更改gatsby-node-js"><a href="#更改gatsby-node-js" class="headerlink" title="更改gatsby-node.js"></a>更改gatsby-node.js</h2><p>首先需要定义每页文章数，并据此计算出总页面数：</p><pre><code>const postsPerPage = 12const numPages = Math.ceil(data.allMarkdownRemark.nodes.length / postsPerPage)</code></pre><p>接下来需要在生成页面的时候，定义相应的规则。以标签页面的生成为例：</p><pre><code>tags.forEach(tag =&gt; {    Array.from({ length: numPages }).forEach((_, i) =&gt; {      actions.createPage({        path: i === 0 ? `/tags/${tag}` : `/tags/${tag}/${i + 1}`,        component: path.resolve(&apos;./src/templates/tag.js&apos;),        context: {          tag: tag,          currentPage: i+1,          totalPage: numPages,          limit: postsPerPage,          skip: i * postsPerPage,        },      })    })})</code></pre><p>这样就会定义：</p><ul><li>不同页对应的文件路径，比如第一页为：tags/video；第二页为：tags/video/2</li><li>相应的参数：currentPage, totalPage, limit, skip。这些参数将通过pageContext传递给生成页面的模板。</li></ul><p>接下来时对相应页面生成模板的定义：</p><pre><code>import React from &quot;react&quot;import { graphql, Link } from &apos;gatsby&apos;import Layout from &quot;../components/Layout&quot;import PostSummary from &apos;../components/PostSummary&apos;import &apos;../styles/global.css&apos;import &apos;../styles/video.css&apos;const TagPage = ({pageContext, data}) =&gt; {  const { tag, totalPage, currentPage } = pageContext;   const posts = data.posts.nodes;  return (    &lt;Layout&gt;      &lt;div className=&quot;videos-title&quot;&gt;          &lt;h3&gt;标签：{tag}&lt;/h3&gt;          &lt;div className=&quot;videotutorials&quot;&gt;              {posts.map((post) =&gt; {                  return(                    &lt;PostSummary post={post}/&gt;                     )              })}          &lt;/div&gt;      &lt;/div&gt;      &lt;div&gt;        {currentPage - 1 &gt; 0 &amp;&amp; (          &lt;Link            to={`/tags/${tag}/` + (currentPage - 1 === 1 ? &apos;&apos; : currentPage - 1)}            rel=&quot;prev&quot;          &gt;            ← 上一页          &lt;/Link&gt;        )}        {currentPage + 1 &lt;= totalPage &amp;&amp; (          &lt;Link to={`/tags/${tag}/` + (currentPage + 1)} rel=&quot;next&quot;&gt;            下一页 →          &lt;/Link&gt;        )}      &lt;/div&gt;    &lt;/Layout&gt;  )}export default TagPageexport const query = graphql`  query TagQuery($tag: String, $skip: Int!, $limit: Int!) {    posts: allMarkdownRemark(      filter: {frontmatter: {tag: {eq: $tag}}}      sort: {fields: frontmatter___date, order: DESC}      limit: $limit      skip: $skip    ) {      nodes {        frontmatter {          title          slug          keywords          thumbnail {            childImageSharp {              fluid {                ...GatsbyImageSharpFluid              }            }          }          category          tag          date        }        id      }    }  }`</code></pre><p>至此，在使用gatsby build时就会在标签下生成对应的子文件夹，比如在/tags/video/下还会生成1/，2/，3/等子目录及其中的index.html。</p>]]></content>
    
    <summary type="html">
    
      如何在Gatsby中实现分页
    
    </summary>
    
      <category term="技术" scheme="https://www.aafeng.uk/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JavaScript" scheme="https://www.aafeng.uk/tags/JavaScript/"/>
    
      <category term="Gatsby" scheme="https://www.aafeng.uk/tags/Gatsby/"/>
    
  </entry>
  
  <entry>
    <title>秋天的味道</title>
    <link href="https://www.aafeng.uk/taste-of-autumn/"/>
    <id>https://www.aafeng.uk/taste-of-autumn/</id>
    <published>2021-10-19T22:07:18.186Z</published>
    <updated>2021-10-19T22:07:18.186Z</updated>
    
    <content type="html"><![CDATA[<p>女儿的作业又下来了，这次让用纯天然的材料做一个小工艺品。哎，又要拼爹了。。。</p><p>既然是纯天然的，那只能去周边转转，看看有没有什么好的材料。女儿还特别认真：老师说的，只能从地上捡，不从从树上摘，嗯，好吧。。。</p><p>现在应该是栗子成熟的季节，于是先去了每年都去的栗子数附近，捡了一些栗子回来。但敲开壳之后才发现，似乎还差些时候，但做手工制品没有问题。</p><p>另外还有一种马栗，长得和栗子有些像。不能食用，但可以用来喂牲畜。它和栗子的区别还是很明显的：马栗的外壳虽然也有尖刺，但并不是特别密集，也不是特别扎手。而食用栗子的外壳长满了又尖又密的小刺，根本没法用手抓。同时其果实上还有“毛发”。</p><p>除了马栗和栗子，还捡到了一些落叶及野果。想想素材应该是足够了。于是打道回府，开始第二阶段的工作。</p><p>首先是计划，和女儿商量好了，打算由她画一幅秋天的风景作为背景，我负责制作两个小人，然后把两者结合起来。</p><p>说干就干，先用电钻在马栗上钻了几个小孔，然后用牙签为其装上了手脚和头部。很快，女儿的画也画好了。都拼在一起的感觉似乎还是很不错的：</p><p><img src="https://user-images.githubusercontent.com/63479035/137996822-416abdae-faa8-417c-8d5b-053070210e17.png" alt="女儿的Homework"><br>摄于2021.10.19</p>]]></content>
    
    <summary type="html">
    
      秋天的味道
    
    </summary>
    
      <category term="生活" scheme="https://www.aafeng.uk/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>手机定位软件Family360</title>
    <link href="https://www.aafeng.uk/mobile-phone-locator/"/>
    <id>https://www.aafeng.uk/mobile-phone-locator/</id>
    <published>2021-10-02T22:35:08.414Z</published>
    <updated>2021-10-02T22:35:08.414Z</updated>
    
    <content type="html"><![CDATA[<p>自从儿子上初中后，发现他的大多数同学都是自己做公交车回家的。于是也打算尝试一下。但作为家长，最为担心的就是孩子的安全问题。这就非常需要一个手机定位的APP，能够随时看到孩子的位置。</p><p><img src="https://user-images.githubusercontent.com/63479035/135529905-4e8be364-9eef-4f6c-a8d7-46bc9d642c24.png" alt="image"><br>Source: 软件Google Play Store截屏</p><a id="more"></a><p>其实，曾经从国内买过小米的智能手表，可以随时定位。但手表的功能有限。而现在中学的小朋友们彼此之间也需要使用各种APP沟通交流，于是智能手表就有些不够用了。</p><p>于是开始选择这种GPS定位软件。在网上查了一下，类似的软件非常多。包括很多需要付费的，可见这种需求还是很大的。这里选择了Family 360。</p><p>这个APP中的首要功能是定义自己的圈子（circle），然后可以把所有家庭成员加入到这个圈子中，后面就可以监测家庭成员的位置信息了。</p><p><img src="https://user-images.githubusercontent.com/63479035/135716146-875a1335-36fc-49b1-b018-f3a588df300f.png" alt="image"></p><p>接下来可以定义几个范围（免费版本可以定义两个范围）。在定义范围的时候，首先需要选择一个地址，然后定义一个半径，那么只要成员超过这个圆所覆盖的范围，就会发出自动提醒。感觉这个功能对监测孩子的位置还是非常有用的。</p><p>APP中还能定义一个超速的限制，这在以后孩子大些刚开始开车的时候应该很有用吧。如果超速就会提示。</p><p><img src="https://user-images.githubusercontent.com/63479035/135716074-3b830245-5f95-4a9d-b660-aa682dfb1abd.png" alt="image"></p><p>整体感觉这个软件非常简单，功能很单一。貌似也很好用。需要试试看它的定位是不是很精确。</p>]]></content>
    
    <summary type="html">
    
      手机定位软件Family360
    
    </summary>
    
      <category term="育儿" scheme="https://www.aafeng.uk/categories/%E8%82%B2%E5%84%BF/"/>
    
    
  </entry>
  
  <entry>
    <title>Gatsby中的动态页面生成</title>
    <link href="https://www.aafeng.uk/gatsby-page-generation/"/>
    <id>https://www.aafeng.uk/gatsby-page-generation/</id>
    <published>2021-09-30T08:41:05.747Z</published>
    <updated>2021-09-30T08:41:05.747Z</updated>
    
    <content type="html"><![CDATA[<p>Gatsby是目前非常流行的静态页面生成框架。 页面生成是其最核心功能之一。 下面就来说说如何在Gatsby中自动生成文章页面，Category分类页面，以及tags标签页面。</p><p><img src="https://user-images.githubusercontent.com/63479035/135064099-e2e1247d-a658-484b-8618-a85bfc56ac7a.png" alt="image"><br>Source: Gatsby官网</p><a id="more"></a><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="gatsby-config-js中的配置"><a href="#gatsby-config-js中的配置" class="headerlink" title="gatsby-config.js中的配置"></a>gatsby-config.js中的配置</h3><p>首先需要声明对markdown文件的监测，这样gatsby才能获取markdown中的frontmatter信息，比如slug：</p><pre><code>{  resolve: `gatsby-source-filesystem`,  options: {    name: `posts`,    path: `${__dirname}/src/posts`  }}</code></pre><h2 id="动态生成页面文件"><a href="#动态生成页面文件" class="headerlink" title="动态生成页面文件"></a>动态生成页面文件</h2><h3 id="gatsby-node-js"><a href="#gatsby-node-js" class="headerlink" title="gatsby-node.js"></a>gatsby-node.js</h3><p>接下来就可以在gatsby-node.js中通过graphql来获取所有markdown的元数据，也就是frontmatter信息：</p><pre><code>const { data } = await graphql(`    query posts {      allMarkdownRemark {        nodes {          frontmatter {            slug            category            tag          }        }      }    }`)</code></pre><p>通过上面的graphql，就可以获取最为重要的信息，比如slug，这样我们就知道将要生成的文件名了。</p><p>接下来就可以调用actions.createPage来创建页面了：</p><pre><code>data.allMarkdownRemark.nodes.forEach(node =&gt; {    actions.createPage({      path: `/posts/${node.frontmatter.slug}`,      component: path.resolve(&apos;./src/templates/post.js&apos;),      context: { slug: node.frontmatter.slug }    })})</code></pre><p>这里需要的模板文件： ./src/templates/post.js</p><p>首先需要通过传递过来的slug查询相应页面：</p><pre><code>export const query = graphql`  query PageDetails($slug: String) {    markdownRemark(frontmatter: {slug: {eq: $slug}}) {      html      frontmatter {        category        tag        title        thumbnail {          childImageSharp {            fluid {              ...GatsbyImageSharpFluid            }          }        }      }    }  }`</code></pre><p>接下来就可以生成页面了：</p><pre><code>import React from &quot;react&quot;import { graphql } from &apos;gatsby&apos;import Img from &quot;gatsby-image&quot;import Layout from &quot;../components/Layout&quot;import &apos;../styles/post.css&apos;const Post = ({data}) =&gt; {  const { html } = data.markdownRemark  const { title, category, tag, thumbnail } = data.markdownRemark.frontmatter  return (    &lt;Layout&gt;      &lt;div&gt;        &lt;h2&gt;{title}&lt;/h2&gt;        &lt;p&gt;类别: {category}&lt;/p&gt;        &lt;p&gt;标签: {tag}&lt;/p&gt;        &lt;div&gt;          &lt;Img fluid={thumbnail.childImageSharp.fluid} /&gt;        &lt;/div&gt;        &lt;div dangerouslySetInnerHTML={{__html: html}} /&gt;      &lt;/div&gt;    &lt;/Layout&gt;  )}export default Post</code></pre><p>这时重新启动gatsby，就可以访问页面了： /posts/xxxxxx 。 如果运行gatasby build就可以看到在public目录中新生成的页面。</p><h2 id="生成自定义的category-tag页面"><a href="#生成自定义的category-tag页面" class="headerlink" title="生成自定义的category/ tag页面"></a>生成自定义的category/ tag页面</h2><p>在很多博客站点中，都提供针对某一个category / tag的页面，这样可以把同类的文章汇总到一起。</p><p>首先还是在gatsby-node.js中的预处理：</p><pre><code>categories = new Set()tags = new Set() data.allMarkdownRemark.nodes.forEach(node =&gt; {  actions.createPage({    path: `/${node.frontmatter.category}/${node.frontmatter.slug}`,    component: path.resolve(&apos;./src/templates/details.js&apos;),    context: { slug: node.frontmatter.slug }  })  categories.add(node.frontmatter.category);  node.frontmatter.tag.forEach(t =&gt; {    tags.add(t);  })})categories.forEach(category =&gt; {  actions.createPage({    path: `/categories/${category}`,    component: path.resolve(&apos;./src/templates/category.js&apos;),    context: { category: category }  })})tags.forEach(tag =&gt; {  actions.createPage({    path: `/tags/${tag}`,    component: path.resolve(&apos;./src/templates/tag.js&apos;),    context: { tag: tag }  })})</code></pre><p>接下来是在模板文件src/templates/tag.js中的处理：</p><pre><code>import React from &quot;react&quot;import { graphql, Link } from &apos;gatsby&apos;import Img from &quot;gatsby-image&quot;const Tag = ({pageContext, data}) =&gt; {  const { tag } = pageContext;   const posts = data.posts.nodes;  return (    &lt;&gt;      &lt;div&gt;          &lt;h3&gt;标签：{tag}&lt;/h3&gt;          &lt;div&gt;              {posts.map((post) =&gt; {                  const {frontmatter} = post;                  return(                      &lt;div key={post.id}&gt;                          &lt;h3&gt;                              &lt;Link to={`/${post.frontmatter.category}/${post.frontmatter.slug}`}&gt;                                  {frontmatter.title}                              &lt;/Link&gt;                          &lt;/h3&gt;                          &lt;Img fluid={frontmatter.thumbnail.childImageSharp.fluid}/&gt;                          &lt;p&gt;发布日期: {frontmatter.date.substring(0,10)}&lt;/p&gt;                          &lt;p&gt;类别:                            &lt;Link to={`/categories/${frontmatter.category}`}&gt;                              {frontmatter.category}                            &lt;/Link&gt;                            &lt;/p&gt;                          &lt;p&gt;标签：{                          frontmatter.tag.map(t =&gt; {                              return (                                &lt;Link to={`/tags/${t}`}&gt;                                  &lt;span className=&quot;tag&quot;&gt;{t}&lt;/span&gt;                                &lt;/Link&gt;                                )                          })                          }&lt;/p&gt;                      &lt;/div&gt;                      )              })}          &lt;/div&gt;      &lt;/div&gt;    &lt;/&gt;  )}export default Tagexport const query = graphql`  query TagQuery($tag: String) {    posts: allMarkdownRemark(      filter: {frontmatter: {tag: {eq: $tag}}}      sort: {fields: frontmatter___date, order: DESC}    ) {      nodes {        frontmatter {          title          slug          keywords          thumbnail {            childImageSharp {              fluid {                ...GatsbyImageSharpFluid              }            }          }          category          tag          date        }        id      }    }  }`</code></pre><p>catetory页面的实现类似。</p>]]></content>
    
    <summary type="html">
    
      Gatsby中的动态页面生成
    
    </summary>
    
      <category term="技术" scheme="https://www.aafeng.uk/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JavaScript" scheme="https://www.aafeng.uk/tags/JavaScript/"/>
    
      <category term="Gatsby" scheme="https://www.aafeng.uk/tags/Gatsby/"/>
    
  </entry>
  
  <entry>
    <title>Gatsby中的图片优化</title>
    <link href="https://www.aafeng.uk/gatsby-image/"/>
    <id>https://www.aafeng.uk/gatsby-image/</id>
    <published>2021-09-30T05:54:32.364Z</published>
    <updated>2021-09-30T05:54:32.364Z</updated>
    
    <content type="html"><![CDATA[<p>Gatsby是现在比较流行的一个静态网站生成框架。通过它，可以快速的生成React网站，同时又解决了React应用SEO不友好的问题。这里主要说一说Gatsby中的图片优化问题。</p><p><img src="https://user-images.githubusercontent.com/63479035/135064099-e2e1247d-a658-484b-8618-a85bfc56ac7a.png" alt="image"><br>Source: Gatsby官网</p><a id="more"></a><h2 id="gatsby中静态图片的使用"><a href="#gatsby中静态图片的使用" class="headerlink" title="gatsby中静态图片的使用"></a>gatsby中静态图片的使用</h2><p>在默认情况下，可以把图片放于static目录中，然后在页面中直接引用就可以了：</p><pre><code>&lt;img src=“/banner.jpg&quot; alt=&quot;site banner&quot; /&gt;</code></pre><p>但这种方式的缺点也是非常明显的：</p><ul><li>针对不同的设备，通常可以显示更为适合的图片。比如对于高清的大屏幕，可以显示分辨率最高的图片，但对于尺寸较小的手机，只需要显示分辨率较小的图片就可以了。这样就可以大大提高页面加载速度。</li><li>懒加载。很多网站都实现了这个功能。在开始装载页面的时候，用户看到的是一个分辨率极低，但加载速度很快的模糊图片，随着页面加载的完成，该图片就会被一个高清图片替代。</li></ul><p>如果解决以上两个问题，可以大大提高用户体验。</p><h2 id="使用gatsby-image及相关组件实现自适应图片"><a href="#使用gatsby-image及相关组件实现自适应图片" class="headerlink" title="使用gatsby-image及相关组件实现自适应图片"></a>使用gatsby-image及相关组件实现自适应图片</h2><h3 id="安装依赖库"><a href="#安装依赖库" class="headerlink" title="安装依赖库"></a>安装依赖库</h3><p>在Gatsby中，可以通过几个插件来实现这样的功能。因此首先需要在Gatsby项目中安装插件：</p><pre><code>npm install gatsby-image gatsby-transformer-sharp gatsby-plugin-sharp</code></pre><p>其中，gatsby-image的作用是支持在gatsby中使用图片<br>gatsby-transformer-sharp和gatsby-plugin-sharp的作用是处理image并在graphql层中提供相应的额外图片数据。这样就可以在应用中使用由gatsby优化过的图片，而不是固定的静态图片。</p><h3 id="添加图片"><a href="#添加图片" class="headerlink" title="添加图片"></a>添加图片</h3><p>接下来创建src/images目录，并将图片，比如banner.jpg复制到该目录中。</p><h3 id="更新配置文件gatsby-config-js"><a href="#更新配置文件gatsby-config-js" class="headerlink" title="更新配置文件gatsby-config.js"></a>更新配置文件gatsby-config.js</h3><p>更新gatsby-config.js配置文件。首先添加对以上插件的声明，同时添加对src/images目录的监视：</p><pre><code>plugins: [  &apos;gatsby-transformer-sharp&apos;,  &apos;gatsby-plugin-sharp&apos;,          ……   {      resolve: `gatsby-source-filesystem`,      options: {        name: `images`,        path: `${__dirname}/src/images`      }   }</code></pre><p>重新启动gatsby：</p><pre><code>gatsby develop</code></pre><h3 id="在graphql层中获取自适应图片"><a href="#在graphql层中获取自适应图片" class="headerlink" title="在graphql层中获取自适应图片"></a>在graphql层中获取自适应图片</h3><p>然后进行如下的graphql查询：</p><pre><code>query MyQuery {  file(relativePath: {eq: &quot;banner.png&quot;}) {    childImageSharp {      fluid {        src        srcSet        sizes      }    }  }}</code></pre><p>上面fluid中的查询也可以简写作：</p><pre><code>fluid {    ...GatsbyImageSharpFluid}</code></pre><p>其返回值为：</p><pre><code>{  &quot;data&quot;: {    &quot;file&quot;: {      &quot;childImageSharp&quot;: {        &quot;fluid&quot;: {          &quot;src&quot;: &quot;/static/fa84b2b0a8b220dca8e981bfb0efac59/de334/banner.png&quot;,          &quot;srcSet&quot;: &quot;/static/fa84b2b0a8b220dca8e981bfb0efac59/69585/banner.png 200w,\n/static/fa84b2b0a8b220dca8e981bfb0efac59/497c6/banner.png 400w,\n/static/fa84b2b0a8b220dca8e981bfb0efac59/de334/banner.png 798w&quot;,          &quot;sizes&quot;: &quot;(max-width: 798px) 100vw, 798px&quot;        }      }    }  },  &quot;extensions&quot;: {}}</code></pre><p>可以看到，gatsby的插件已经对banner.png进行了处理，并在static目录中生成了三个不同尺寸的图片：200px, 400px, 798px。</p><h3 id="在页面中使用自适应图片"><a href="#在页面中使用自适应图片" class="headerlink" title="在页面中使用自适应图片"></a>在页面中使用自适应图片</h3><p>接下来就可以在应用中通过这组图片(srcSet)进行自适应了。比如在首页中使用这个banner，首先导入相应的模块：</p><pre><code>import { graphql } from &quot;gatsby&quot;import Img from &apos;gatsby-image&apos;</code></pre><p>然后在文件底部声明graphql查询：</p><pre><code>export const query = graphql`  query Banner {    file(relativePath: {eq: &quot;banner.png&quot;}) {      childImageSharp {        fluid {          ...GatsbyImageSharpFluid        }      }    }  }`</code></pre><p>然后就可以在页面组件中使用这个图片了：</p><pre><code>export default function Home({data}) {    // ...    &lt;Img fluid={data.file.childImageSharp.fluid}/&gt;    // ...}</code></pre><p>可以看到在浏览器中，gatsby已经为我们生成了一个picture标签：</p><p><img src="https://user-images.githubusercontent.com/63479035/135063940-afa487a0-be34-4bae-852f-58cd17170776.png" alt="image"></p><p><strong>注意：在开发的过程中如果发现页面中总有错误提示的话，有可能是gatsby的缓存所致，这时清除.cache / public目录后再重启gatsby一般就可以解决。</strong></p><h3 id="如何将markdown文件中指定的图片转换为自适应图片"><a href="#如何将markdown文件中指定的图片转换为自适应图片" class="headerlink" title="如何将markdown文件中指定的图片转换为自适应图片"></a>如何将markdown文件中指定的图片转换为自适应图片</h3><p>在markdown文件的头部，可以指定类似的属性：</p><pre><code>---thumbnail: ../images/tutorials.png---</code></pre><p><strong>需要注意： 上面文件的路径一定要是相对路径，这样gatsby的图片组件才能找到图片并进行自适应处理。</strong></p><p>可以看到，在graphql层中，frontmatter下的thumbnail属性中已经添加了相应的子属性：</p><pre><code>query VideoQuery {    videos: allMarkdownRemark(filter: {frontmatter: {category: {eq: &quot;video&quot;}}}) {        nodes {            frontmatter {                title                date                slug                keywords                thumbnail{                    childImageSharp {                      fluid {                        ...GatsbyImageSharpFluid                      }                    }                }                category                tag            }            id        }    }}</code></pre><p>这样就可以在页面中使用了：</p><pre><code>import Img from &apos;gatsby-image&apos;    // ...&lt;Img fluid={frontmatter.thumbnail.childImageSharp.fluid}/&gt;    </code></pre>]]></content>
    
    <summary type="html">
    
      Gatsby中的图片优化
    
    </summary>
    
      <category term="技术" scheme="https://www.aafeng.uk/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JavaScript" scheme="https://www.aafeng.uk/tags/JavaScript/"/>
    
      <category term="Gatsby" scheme="https://www.aafeng.uk/tags/Gatsby/"/>
    
  </entry>
  
  <entry>
    <title>在英国尝试做新疆大盘鸡</title>
    <link href="https://www.aafeng.uk/xinjiangdapanji/"/>
    <id>https://www.aafeng.uk/xinjiangdapanji/</id>
    <published>2021-09-28T09:50:39.699Z</published>
    <updated>2021-09-28T09:50:39.699Z</updated>
    
    <content type="html"><![CDATA[<p>最近由于晚上不吃饭，中午时间又没有时间做饭，感觉已经好长时间没有好好吃饭了。于是这个周末决定给自己改善一下，做一下自己的拿手菜：新疆大盘鸡。</p><p><img src="https://user-images.githubusercontent.com/63479035/134817413-cd593712-c202-4a00-bf61-e02d36c7a3de.png" alt="image"></p><p>原来在国内工作的时候，经常和同事朋友一起去新疆馆子吃饭，拉条子，烤串，大盘鸡都是我们的最爱。但到了英国后就没有这个口福了。后来在一次很偶然的机会和朋友聊起了新疆大盘鸡，于是决定自己尝试一下。记得当时提出这个想法的时候，大家都不相信能自己做出新疆大盘鸡来。但做好上桌的时候，大家的嘴都咧到耳朵根了，效果和新疆馆子的不相上下。</p><p>好吧，这次完全凭着记忆中的菜单来做的，不知道是不是忘记什么调料了。效果整体还可以，但绝对不是最佳状态，可以打80分吧。</p><p>首先将鸡肉切块，然后用生抽，料酒腌好，然后放置半个小时左右。</p><p>然后准备辅料：葱姜蒜，蘑菇切片，青椒切块，洋葱切块，土豆切滚刀块。</p><p>油热后放入葱姜蒜爆香，放入干辣椒，然后放入洋葱，鸡块炒香。</p><p>之后放入青椒，蘑菇，土豆炒香，然后放入八角和少量水，开大火烧开后转中火炖20分钟。</p><p>接下来准备皮带面。把实现准备好的面擀成薄片，然后切成宽面。将面放入锅中煮熟，然后盛到一个容器中。把烧好的鸡肉连汤带菜浇到面上。</p><p>可以开吃了！</p>]]></content>
    
    <summary type="html">
    
      在英国尝试做新疆大盘鸡
    
    </summary>
    
      <category term="美食" scheme="https://www.aafeng.uk/categories/%E7%BE%8E%E9%A3%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>旧物利用 - 三星Galaxy S2刷机过程记录</title>
    <link href="https://www.aafeng.uk/install-android11-to-samsung-galaxy-s2/"/>
    <id>https://www.aafeng.uk/install-android11-to-samsung-galaxy-s2/</id>
    <published>2021-09-25T20:29:19.174Z</published>
    <updated>2021-09-25T20:34:51.402Z</updated>
    
    <content type="html"><![CDATA[<p>在整理车库的时候，发现了好几个不用的手机，有的是近两年的，有的年头比较久了。对于那些近两年的手机还好，只要恢复出厂设置，重新配置一下账号就能正常使用了。那么对于那些年头久远的手机，是不是要扔掉呢？比如：这款近10岁高龄的三星Galaxy S2。</p><a id="more"></a><p>首先恢复了一下出场设置，在开机后要求配置Google账号。但无论怎么输入，都提示无法连接到Google服务器。在网上查了一下，才发现Google根本不支持Andorid 4以下的版本了。而这款手机还在运行Android 2.3。</p><p>直接扔掉的话感觉有些不甘心。于是在网上找了一下，原来是可以把这款手机刷成Android 11的。既然可以，那就折腾一下看看吧。</p><p>首先需要下载几个文件做好准备：<br><a href="https://androidfilehost.com/?fid=6006931924117917092" rel="external nofollow noopener noreferrer" target="_blank">i9100-LOS-16.0-Emulated-Storage.pit</a><br><a href="https://androidfilehost.com/?fid=6006931924117912732" rel="external nofollow noopener noreferrer" target="_blank">i9100-LOS-16.0-Emulated-Storage-TWRP-3.3.1-1.tar.md5</a><br><a href="https://www.androidfilehost.com/?fid=10763459528675599412" rel="external nofollow noopener noreferrer" target="_blank">lineage-18.0-20201207-unofficial-i9100.zip</a><br><a href="https://odindownloader.com/download/odin3-v3-07" rel="external nofollow noopener noreferrer" target="_blank">Odin3 V3.07</a></p><p>关机后同时按下Home+Volume Down+Power三个键并保持10秒左右，会进入下载模式（Download Mode）。<br>这时需要打开预先安装好的ODIN 3.07，注意一定是这个版本的ODIN。我尝试下载了ODIN 3.14，结果发现界面和3.07很不一样。<br>接下来用USB线把手机连上电脑，这样ODIN应该能够监测到手机。<br>指定PIT/PDA文件。然后单击“Start”开始刷机。<br>刷机完毕后关机，然后按下Home+Volume Up+Power三个键并保持10秒，进入TWRP。</p><p><img src="https://user-images.githubusercontent.com/63479035/134784647-c41d9fed-1b16-4663-8316-873bc126eb47.png" alt="image"></p><p>然后选择：Wipe -&gt; Format Data </p><p>然后进入：Advanced Wipe，进行如下设置后进行清除：</p><p><img src="https://user-images.githubusercontent.com/63479035/134784691-86df9434-7277-4d08-b784-fd827d66e824.png" alt="image"></p><p>清除完毕后安装lineage OS，我这里先尝试着把下载的zip复制到手机Internal storage中，但进入TWRP后找不到这个zip文件，后来改用SD卡后就没有任何问题。这个安装过程非常简单。之后重新启动系统。</p><p>这时就顺利进入Android 11了。不过默认情况下Lineage OS中不含Google套件，因此需要额外安装。我这里下载的是 <a href="https://sourceforge.net/projects/nikgapps/files/Releases/NikGapps-R/" rel="external nofollow noopener noreferrer" target="_blank">NikkGapps</a>，但安装后感觉手机略微有点卡。感觉似乎应该安装更为精简的 <a href="https://forum.xda-developers.com/android/software/custom-bitgapps-android-t4012165" rel="external nofollow noopener noreferrer" target="_blank">BitGapps</a>。不过感觉应该也会卡，毕竟跑起整套Google系统对于10年前的手机来说都应该比较吃力吧。</p><p>至此刷机成功，安装了Gmail, Chrome, Youtube, Whatsapp, 微信等程序后，似乎可以正常使用了。</p><p><img src="https://user-images.githubusercontent.com/63479035/134784927-611cd42d-1db3-48ea-a70a-a76cc07b8f5b.png" alt="image"></p><p>Refs：<br><a href="https://forum.xda-developers.com/t/rom-unofficial-11-0-0-r43-i9100-lineageos-18-1.4199759/" rel="external nofollow noopener noreferrer" target="_blank">https://forum.xda-developers.com/t/rom-unofficial-11-0-0-r43-i9100-lineageos-18-1.4199759/</a></p>]]></content>
    
    <summary type="html">
    
      旧物利用 - 三星Galaxy S2刷机过程记录
    
    </summary>
    
      <category term="技术" scheme="https://www.aafeng.uk/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>好香的Headless CMS - Strapi介绍</title>
    <link href="https://www.aafeng.uk/strapi/"/>
    <id>https://www.aafeng.uk/strapi/</id>
    <published>2021-09-21T17:19:54.908Z</published>
    <updated>2021-09-22T15:40:54.567Z</updated>
    
    <content type="html"><![CDATA[<p>尝试了一下strapi，感觉真的很香，几分钟就能搭建起后台的REST API服务，同时还支持很多插件，比如graphql插件，这就大大加快了开发的速度。</p><p><img src="https://user-images.githubusercontent.com/63479035/134215437-b400282f-8a92-4bac-8d26-37087fc3e323.png" alt="strapi"></p><a id="more"></a><p>其实，之所以喜欢它，最主要还是它的设计出发点：Headless CMS。也就是说，只提供操作数据的API，而不像Wordpress那样同时提供操作数据的UI。（严格的讲，strapi也提供一个非常简单的数据操作界面）</p><h2 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h2><pre><code>mkdir strapi-tutcd strapi-tutnpx create-strapi-app backend</code></pre><p>选择不使用模板。</p><p>安装完毕后访问：<a href="http://localhost:1337/admin" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:1337/admin</a> </p><p><img src="https://user-images.githubusercontent.com/63479035/133749359-a59d35a0-4ddb-458e-b0bc-1d8a0c582ae8.png" alt="image"></p><p>创建管理员用户并登录后会看到如下界面：<br><img src="https://user-images.githubusercontent.com/63479035/133749593-b01eb018-fade-4f30-b1fd-9467cf8b420e.png" alt="image"></p><p>如果停止后下次再重新启动strapi:</p><pre><code>cd backendnpm run develop</code></pre><h2 id="Content-Types"><a href="#Content-Types" class="headerlink" title="Content Types"></a>Content Types</h2><p>一旦安装配置好之后，最重要的一步就是设计各种Content Type了，这就有点像关系型数据库中的表结构。这里共有三种不同类型的Content type: Collection type（针对有多个数据的类型，比如blog, user等）, Single type（针对只出现一次的类型，比如:homepage），以及Component（可反复使用的组件）。在设计时可选的字段类型很丰富：</p><p><img src="https://user-images.githubusercontent.com/63479035/134215681-e138a307-6093-499a-9f64-3920a5d5d2d8.png" alt="image"></p><p>等到这个Content type设计好了之后，strapi就会生成类似于：<a href="http://localhost:1337/reviews" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:1337/reviews</a> 这样的API地址，这样前段就可以非常方便的使用了。</p><h2 id="认证与授权"><a href="#认证与授权" class="headerlink" title="认证与授权"></a>认证与授权</h2><p>当然，作为一个CMS，strapi自然支持Authn/Authz。可以将某项内容指定为public，也可以指定其访问权限，用户组等等。</p><p><img src="https://user-images.githubusercontent.com/63479035/134216463-2d89ce4f-9035-47a2-bd34-9304e5073d89.png" alt="image"></p><p>比如： 允许public访问review的findone / find权限。</p><p><img src="https://user-images.githubusercontent.com/63479035/134375452-af3dab75-514a-4df5-86b5-4dde8075d599.png" alt="image"></p><h2 id="使用Postman进行测试"><a href="#使用Postman进行测试" class="headerlink" title="使用Postman进行测试"></a>使用Postman进行测试</h2><p><strong>推荐在postman中把所有相关测试都保存在一个folder中。</strong></p><h3 id="测试用户登录"><a href="#测试用户登录" class="headerlink" title="测试用户登录"></a>测试用户登录</h3><p><img src="https://user-images.githubusercontent.com/63479035/134375788-c2d17420-d645-4f17-bdce-ea8c6e2bec49.png" alt="image"></p><p>将前面的jwt token复制到Auth -&gt; Type -&gt; Token中，就可以进行Delete/Update/Create操作了。</p><h2 id="对Graphql的支持"><a href="#对Graphql的支持" class="headerlink" title="对Graphql的支持"></a>对Graphql的支持</h2><p>添加了graphql插件的后台就更加好用了：<br><img src="https://user-images.githubusercontent.com/63479035/134217053-dc31a9e2-682e-4549-b213-f5e308f3575b.png" alt="image"></p><p>后台API都搞定了，前台就可以非常愉快的使用Vue/React等玩耍了。。。</p>]]></content>
    
    <summary type="html">
    
      好香的Headless CMS - Strapi
    
    </summary>
    
      <category term="技术" scheme="https://www.aafeng.uk/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>租车</title>
    <link href="https://www.aafeng.uk/leasing-car/"/>
    <id>https://www.aafeng.uk/leasing-car/</id>
    <published>2021-09-14T16:31:57.151Z</published>
    <updated>2021-09-14T16:31:57.151Z</updated>
    
    <content type="html"><![CDATA[<p>之前一直认为只有公司需要用车的时候才需要租车，尤其是长期租车。对于个人用户而言，只有临时车不够用了，或者临时需要更大些的车时，才需要租车。但前一段时间和朋友聊过之后，终于被种草了。最终下定决心，第二辆车不买了，改为租车。</p><p><img src="https://user-images.githubusercontent.com/63479035/133296787-fb09aefb-c634-4c0d-93c8-253ecb7957b3.png" alt="image"><br>Source: Pixabay</p><a id="more"></a><p>在做调研的时候才发现，其实这两年来，租车已经在英国变得越来越流行了。越来越多的人在个人用车上也选择了租车，而不是买车。这样，按照每个月需要交付的钱来说，并不比买车多，但却可以一直开新车。</p><p>综合而言，租车的优势在于：</p><ul><li>不用担心修车的费用，一般租的车都是全新的，在保修期内。因此这些车出故障的几率小，就算出了，车厂也保修。就连一般的维护费用，甚至都包含在租车费用中。</li><li>无需向银行贷款，每月只需支付少量费用就可以。</li><li>因为租车费用较低，可以租用一些自己不会买，更高档次的车。</li><li>合同期满后可以再租用另一类最新款的车，这样就可以一直开新车了。</li><li>我们选择的租车公司还包路税，由于是新车，年检费用也省了。</li><li>如果选择电车，不用担心过几年后电池变得不好用了。反正到时候会换另外一辆新车。</li></ul><p>当然，租车的话也有一些小问题。比如：对于里程数是有限制的，如果超过是有罚款的。同时，如果租的车出现任何损坏，需要赔偿。不过这应该也不算问题吧，自己的车坏了同样需要修，大修走保险，小修自己承担，应该都是一样的。</p><p>现在就坐等新车来了。</p>]]></content>
    
    <summary type="html">
    
      租车
    
    </summary>
    
      <category term="生活" scheme="https://www.aafeng.uk/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>局域网文件传输工具 - SHAREit</title>
    <link href="https://www.aafeng.uk/shareit/"/>
    <id>https://www.aafeng.uk/shareit/</id>
    <published>2021-09-12T18:56:09.017Z</published>
    <updated>2021-09-15T20:01:17.166Z</updated>
    
    <content type="html"><![CDATA[<p>很多时候经常需要在局域网内部的不同设备之间传输文件。在此之前曾经用过飞鸽传书但已经有些年不再使用了。对于小文件也用过Telegram直接传。但在有些时候需要传输大文件的时候就需要一个专门的局域网文件传输工具了，这里推荐使用SHAREit。</p><p><img src="https://user-images.githubusercontent.com/63479035/132983511-79d12701-286d-48a7-a335-1a5d31dff4d4.png" alt="image"><br>图源：官网截图</p><a id="more"></a><p>这是一个完全免费的软件，支持Windows，Mac，苹果/安卓/Windows手机。当然，既然免费，在使用过程中偶尔会弹出广告。</p><p>首先从<a href="https://www.ushareit.com/" rel="external nofollow noopener noreferrer" target="_blank">官网</a>下载并安装，之后启动SHAREit会看到这个界面：</p><p><img src="https://user-images.githubusercontent.com/63479035/133500978-988582ba-d82b-4c04-aba7-d5ba51d44434.png" alt="image"></p><p>如果想要和手机端互传文件的话，需要下载并安装手机客户端。之后通过手机端扫描PC端的二维码，就可以看到如下界面：</p><p><img src="https://user-images.githubusercontent.com/63479035/133501208-95cc2985-87c1-44f4-84e6-34f681866b95.png" alt="image"></p><p>然后就可以开始传输文件了，无论是自己上传还是拖拽都可以：</p><p><img src="https://user-images.githubusercontent.com/63479035/132999104-7aeb82f4-3c88-4c08-bce7-d2fca0c0c4e1.png" alt="image"></p><p>功能非常单一但是好用。推荐！</p>]]></content>
    
    <summary type="html">
    
      局域网文件传输工具 - SHAREit
    
    </summary>
    
      <category term="技术" scheme="https://www.aafeng.uk/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="工具" scheme="https://www.aafeng.uk/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>好香的定制工作流工具 - Pipedream</title>
    <link href="https://www.aafeng.uk/pipedream/"/>
    <id>https://www.aafeng.uk/pipedream/</id>
    <published>2021-08-28T09:41:47.582Z</published>
    <updated>2021-08-28T09:45:02.935Z</updated>
    
    <content type="html"><![CDATA[<p>最近看到了Pipedream这个在线自动化工具，试用了一下，感觉非常好。通过Pipedream，可以自己定义在线工作流。总结一下，它的以下特点最为吸引我：</p><ul><li>良心的免费版本。其免费版本中包括了每月10，000次的调用。相当于每天333次调用。这对于个人用户来说，肯定是够用了。同时对工作流，连接的app，事件源都没有任何限制。</li><li>用户可以自己定义Node.js代码，完全控制工作流。</li><li>完全的无服务器架构，完全不需要自己的服务器就可以自定义很多操作。</li></ul><a id="more"></a><p>这样看来，可以把服务器上的很多cron job都挪到Pipedream上来了。前段时间进行了尝试，把一些cron job挪到了AWS serverless上。尽管AWS的费用并不高，但过了一年试用期后毕竟还是要交费的。而Pipedream这个免费服务似乎就更香了。</p><p>拿自己服务器上的一些cron job来举例来说明Pipedream的用途：</p><ul><li>每天定时检测RSS源，如果有更新，就通过slack/telegram/discord/email消息通知我。</li><li>每天定时检测某个用户的twitter，如果有更新，通知自己。</li><li>调用某个服务器的API，定时给自己发送通知。</li><li>监测Hive CN群中新帖，给大家点赞。</li></ul><p>感觉这些功能应该都很容易的使用Pipedream来实现。</p><p>下面举一个简单的例子来说明Pipedream的使用。</p><p>首先，通过OAuth登录，我这里选择的是通过Google来登录的，同时还可以选择Github账户授权登录。</p><p>登录成功后，创建一个工作流(workflow)。可以看到，有很多的触发器(triggers)，比如：HTTP/Webhook, Twitter, Slack, Telegram, RSS, Email等等。这样工作流的触发条件就非常灵活了。</p><p><img src="https://user-images.githubusercontent.com/63479035/131211967-6f26719d-08e5-4d0b-a8be-b644d7ecad18.png" alt="image"></p><p>比如：我这里选择使用RSS源作为触发器。如下图所示，使用端传媒的RSS作为触发条件：</p><p><img src="https://user-images.githubusercontent.com/63479035/131212245-5437bd76-6911-48d3-b819-103cf9e3adb1.png" alt="image"></p><p>可以看到Pipedream会自动获取最新的RSS作为测试数据源；</p><p><img src="https://user-images.githubusercontent.com/63479035/131212384-61e02c30-1776-429e-a207-c35e7eb53c8d.png" alt="image"></p><p>接下来需要定义下一步的动作了，比如选择最为简单的给自己发送邮件：</p><p>在这一步中，可以选择上一步的输出作为邮件的主体/正文</p><p><img src="https://user-images.githubusercontent.com/63479035/131212686-44725d8c-6774-466c-be74-14eb9cccb0fb.png" alt="image"></p><p>最终选择之后的结果是这样的：</p><p><img src="https://user-images.githubusercontent.com/63479035/131213309-0935d11e-e7ac-4b00-91f4-7dd6b1896845.png" alt="image"></p><p>部署并测试一下，很快就收到了邮件：</p><p><img src="https://user-images.githubusercontent.com/63479035/131213350-5a87df8c-6bf9-47bd-80eb-bd5425a995ac.png" alt="image"></p><p>可以看到，通过Pipedream可以非常方便的定义自己的工作流。</p>]]></content>
    
    <summary type="html">
    
      好香的定制工作流工具 - Pipedream
    
    </summary>
    
      <category term="技术" scheme="https://www.aafeng.uk/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Pipedream" scheme="https://www.aafeng.uk/tags/Pipedream/"/>
    
  </entry>
  
  <entry>
    <title>如何在Express.js中使用Pasport.js进行OAuth(Google,Facebook等)登录</title>
    <link href="https://www.aafeng.uk/oauth-express-passport/"/>
    <id>https://www.aafeng.uk/oauth-express-passport/</id>
    <published>2021-08-12T14:27:41.228Z</published>
    <updated>2021-08-12T15:44:22.027Z</updated>
    
    <content type="html"><![CDATA[<p>现在在Web应用程序中使用OAuth登录非常普遍。好处可以说是太多了。对于用户来说，避免再记一个密码。 对于服务方来说，避免保存用户信息，增加安全性，同时避免了很多麻烦，比如数据隐私。 </p><p><img src="/images/technology/nodejs/oauth.png" alt="OAuth登录"></p><a id="more"></a><p>技术栈：</p><ul><li>Node.js</li><li>Express</li><li>MongoDB</li><li>Passport.js</li></ul><h2 id="配置基本Express应用"><a href="#配置基本Express应用" class="headerlink" title="配置基本Express应用"></a>配置基本Express应用</h2><h3 id="基本Express-APP"><a href="#基本Express-APP" class="headerlink" title="基本Express APP"></a>基本Express APP</h3><p>首先创建基本的Express应用程序。</p><pre><code>mkdir oauth-democd oauth-demonpm init</code></pre><p>安装依赖库：</p><pre><code>npm install -g nodemonnpm install express ejs mongoose passport passport-google-oauth20 cookie-session</code></pre><h3 id="创建相关目录"><a href="#创建相关目录" class="headerlink" title="创建相关目录"></a>创建相关目录</h3><pre><code>mkdir configmkdir modelsmkdir routesmkdir views</code></pre><h3 id="添加基本文件"><a href="#添加基本文件" class="headerlink" title="添加基本文件"></a>添加基本文件</h3><p>添加app.js:</p><pre><code>const express = require(&apos;express&apos;);const routes = require(&apos;./routes/index&apos;);const app = express();// 使用EJS模板app.set(&apos;view engine&apos;, &apos;ejs&apos;);// 定义路由app.use(&apos;/&apos;, routes);app.listen(3000, &apos;0.0.0.0&apos;, () =&gt; {    console.log(&apos;Listening on port 3000.&apos;);});module.exports = app;</code></pre><p>添加文件routes/index.js:</p><pre><code>const express = require(&apos;express&apos;);const router = express.Router();router.get(&apos;/&apos;, (req, res) =&gt; {    res.render(&apos;index&apos;, { user: req.user });});module.exports = router;</code></pre><p>添加文件：views/index.ejs:</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    Homepage&lt;/body&gt;&lt;/html&gt;</code></pre><p>启动app：</p><pre><code>nodemon app</code></pre><p>就可以在3000端口访问应用了。</p><h3 id="配置MongoDB"><a href="#配置MongoDB" class="headerlink" title="配置MongoDB"></a>配置MongoDB</h3><p>MongoDB官网的免费账户可以使用0.5 GB的空间，这作为学习用是足够的了。官网可以通过Google账号直接登录，非常方便。</p><p>选择Build a Database：<br><img src="https://user-images.githubusercontent.com/63479035/128933345-0355d160-100f-485e-92db-a792bd2c78f1.png" alt="image"></p><p>选择免费版本。</p><p>在之后的Cloud Provider，我选择的是AWS，region中我选择距离我最近的Ireland。之后选择创建集群。</p><p>之后创建一个Database及Collection：<br><img src="https://user-images.githubusercontent.com/63479035/128934645-9650bbf6-a34a-40a6-a5aa-651ac8196eb1.png" alt="image"></p><p>单击下面的Connect获取连接字符串：<br><img src="https://user-images.githubusercontent.com/63479035/128934823-979ad4a3-cae4-4bc7-8ce9-6e24ad979623.png" alt="image"></p><p>这样你将获取一个类似如下的连接字符串：</p><pre><code>mongodb+srv://dbUser:&lt;password&gt;@cluster0.t8uav.mongodb.net/myFirstDatabase?retryWrites=true&amp;w=majority</code></pre><p>这个信息不要提交到git仓库中，建议可以保存在一个特殊的文件中，比如：config/credentials.js:</p><pre><code>module.exports = {    mongodb: {        URI: &apos;mongodb+srv://dbUser:password@cluster0.t8uav.mongodb.net/aafeng?retryWrites=true&amp;w=majority&apos;    }};</code></pre><p>同时更新.gitignore文件：</p><pre><code>node_modulesconfig/credentials.js</code></pre><h2 id="使用Bootstrap"><a href="#使用Bootstrap" class="headerlink" title="使用Bootstrap"></a>使用Bootstrap</h2><h3 id="添加views-header-ejs"><a href="#添加views-header-ejs" class="headerlink" title="添加views/header.ejs"></a>添加views/header.ejs</h3><pre><code>&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;OAuth&lt;/title&gt;    &lt;link href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot; integrity=&quot;sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC&quot; crossorigin=&quot;anonymous&quot;&gt;    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.0.1/dist/js/bootstrap.bundle.min.js&quot; integrity=&quot;sha384-gtEjrD/SeCtmISkJkNUaaKMoLD0//ElJ19smozuHV6z3Iehds+3Ulb9Bn9Plx0x4&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;&lt;/head&gt;</code></pre><h3 id="添加views-nav-ejs"><a href="#添加views-nav-ejs" class="headerlink" title="添加views/nav.ejs"></a>添加views/nav.ejs</h3><pre><code>&lt;!-- navbar --&gt;&lt;nav class=&quot;navbar navbar-expand-md navbar-light pt-5 pb-4&quot;&gt;    &lt;div class=&quot;container-xxl&quot;&gt;        &lt;!-- navbar brand / title --&gt;        &lt;span class=&quot;text-secondary fw-bold&quot;&gt;            OAuth Demo        &lt;/span&gt;        &lt;/a&gt;        &lt;ul class=&quot;navbar-nav&quot;&gt;            &lt;li class=&quot;nav-item&quot;&gt;            &lt;a class=&quot;nav-link&quot; href=&quot;/&quot;&gt;Home&lt;/a&gt;            &lt;/li&gt;            &lt;li class=&quot;nav-item&quot;&gt;            &lt;a class=&quot;nav-link&quot; href=&quot;/profile&quot;&gt;Profile&lt;/a&gt;            &lt;/li&gt;            &lt;li class=&quot;nav-item&quot;&gt;            &lt;a class=&quot;nav-link&quot; href=&quot;/login&quot;&gt;Login&lt;/a&gt;            &lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;&lt;/nav&gt;</code></pre><h3 id="添加views-footer-ejs"><a href="#添加views-footer-ejs" class="headerlink" title="添加views/footer.ejs"></a>添加views/footer.ejs</h3><pre><code>&lt;footer&gt;    aafeng&apos;s blog&lt;/footer&gt;</code></pre><h3 id="添加index-ejs-profile-ejs-login-ejs"><a href="#添加index-ejs-profile-ejs-login-ejs" class="headerlink" title="添加index.ejs,profile.ejs,login.ejs"></a>添加index.ejs,profile.ejs,login.ejs</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;%- include(&apos;partials/header.ejs&apos;) %&gt;&lt;body&gt;    &lt;%- include(&apos;partials/nav.ejs&apos;) %&gt;    &lt;h2&gt;Homepage&lt;/h2&gt;    &lt;%- include(&apos;partials/footer.ejs&apos;) %&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="实现Google-OAuth登录"><a href="#实现Google-OAuth登录" class="headerlink" title="实现Google OAuth登录"></a>实现Google OAuth登录</h2><h3 id="添加routes-oauthRoutes-js"><a href="#添加routes-oauthRoutes-js" class="headerlink" title="添加routes/oauthRoutes.js"></a>添加routes/oauthRoutes.js</h3><pre><code>const router = require(&apos;express&apos;).Router();const passport = require(&apos;passport&apos;);// 注销router.get(&apos;/logout&apos;, (req, res) =&gt; {    req.logout();    res.redirect(&apos;/&apos;);});// 通过Google登录router.get(&apos;/google&apos;, passport.authenticate(&apos;google&apos;, {    scope:[&apos;profile&apos;]}));// Google登陆后的回调router.get(&apos;/google/redirect&apos;, passport.authenticate(&apos;google&apos;), (req, res)=&gt;{    // passport会自动将user信息添加到req中    // 登录完后自动跳转到/profile    res.redirect(&apos;/profile&apos;);})module.exports = router;</code></pre><h3 id="注册oauth路由"><a href="#注册oauth路由" class="headerlink" title="注册oauth路由"></a>注册oauth路由</h3><p>在app.js中，</p><pre><code>const oauthRoutes = require(&apos;./routes/oauthRoutes&apos;);app.use(&apos;/auth&apos;, oauthRoutes);</code></pre><h3 id="创建models-user-model-js"><a href="#创建models-user-model-js" class="headerlink" title="创建models/user-model.js"></a>创建models/user-model.js</h3><pre><code>const mongoose = require(&apos;mongoose&apos;);const Schema = mongoose.Schema;const userSchema = new Schema({    username: String,    provider_and_id: String,    thumbnail: String});const User = mongoose.model(&apos;user&apos;, userSchema);module.exports = User;</code></pre><h3 id="通过passport实现Google登录及用户创建-读取逻辑"><a href="#通过passport实现Google登录及用户创建-读取逻辑" class="headerlink" title="通过passport实现Google登录及用户创建/读取逻辑"></a>通过passport实现Google登录及用户创建/读取逻辑</h3><pre><code>const passport = require(&apos;passport&apos;);const GoogleStrategy = require(&apos;passport-google-oauth20&apos;);const credentials = require(&apos;./credentials&apos;);const User = require(&apos;../models/user-model&apos;);passport.serializeUser((user, done) =&gt; {    done(null, user.id);});passport.deserializeUser((id, done) =&gt; {    User.findById(id).then((user) =&gt; {        done(null, user);    });});passport.use(    new GoogleStrategy({        callbackURL: &apos;/auth/google/redirect&apos;,        clientID: credentials.google.clientID,        clientSecret: credentials.google.clientSecret    }, (accessToken, refreshToken, profile, done) =&gt; {        // 如果用户已经存在        User.findOne({provider_and_id: `google_${profile.id}`}).then((currentUser) =&gt; {            if(currentUser){                // already have this user                console.log(&apos;user is: &apos;, currentUser);                // do something                done(null, currentUser);            } else {                // if not, create user in our db                console.log(profile);                new User({                    provider_and_id: `google_${profile.id}`,                    username: profile.displayName,                    thumbnail: profile._json.picture                }).save().then((newUser) =&gt; {                    console.log(&apos;created new user: &apos;, newUser);                    // do something                    done(null, newUser);                });            }        });    }));</code></pre><p>在routes/oauthRoutes.js中：</p><pre><code>// 通过Google登录router.get(&apos;/google&apos;, passport.authenticate(&apos;google&apos;, {    scope:[&apos;profile&apos;]}));// Google登陆后的回调，这里仍需要调用中间件passport.authenticate(&apos;google&apos;)，// 用于和Google交换数据router.get(&apos;/google/redirect&apos;, passport.authenticate(&apos;google&apos;), (req, res)=&gt;{    // passport会自动将user信息添加到req中    // 登录完后自动跳转到/profile    res.redirect(&apos;/&apos;);})</code></pre><h3 id="通过session-cookie保存登录信息，并保护特定页面"><a href="#通过session-cookie保存登录信息，并保护特定页面" class="headerlink" title="通过session/cookie保存登录信息，并保护特定页面"></a>通过session/cookie保存登录信息，并保护特定页面</h3><p><strong>特别需要注意，添加cookie/session模块并在app.js中注册，否则passport无法保存登录状态！</strong></p><pre><code>const cookieSession = require(&apos;cookie-session&apos;);// 使用Cookieapp.use(cookieSession({    maxAge: 7 * 24 * 60 * 60 * 1000,  // Cookie保存一周    keys: [credentials.session.cookieKey]}));</code></pre><p>在/profile路由中指定auth中间件来保护这个页面，文件：routes/index.js:</p><pre><code>const authCheck = (req, res, next) =&gt; {    // console.log(req.user);    if(!req.user){        res.redirect(&apos;/login&apos;);    } else {        next();    }};router.get(&apos;/profile&apos;, authCheck, (req, res) =&gt; {    res.render(&apos;profile&apos;, { user: req.user });});</code></pre><p>在profile.ejs中：</p><pre><code>&lt;% if (user) { %&gt;    &lt;img src=&quot;&lt;%= user.thumbnail %&gt;&quot; /&gt;&lt;% } %&gt;</code></pre><h2 id="使用passport-js进行Facebook-OAuth登录"><a href="#使用passport-js进行Facebook-OAuth登录" class="headerlink" title="使用passport.js进行Facebook OAuth登录"></a>使用passport.js进行Facebook OAuth登录</h2><h3 id="创建facebook-app并获取clientID-amp-clientSecret"><a href="#创建facebook-app并获取clientID-amp-clientSecret" class="headerlink" title="创建facebook app并获取clientID &amp; clientSecret"></a>创建facebook app并获取clientID &amp; clientSecret</h3><p>访问：<a href="https://developers.facebook.com/" rel="external nofollow noopener noreferrer" target="_blank">https://developers.facebook.com/</a></p><p>需要注意的是，如果使用localhost:3000进行测试的话，需要<strong>创建一个Test App</strong>，而不是New App。在production环境下使用https时才能创建New App。</p><p>安装passport-facebook:</p><pre><code>npm install passport-facebook</code></pre><p>将facebook app的信息保存在config/credentials.js中：</p><pre><code>facebook: {  clientID: &apos;&apos;,  clientSecret: &apos;&apos;},</code></pre><p>在config/passport-init.js中，添加对FacebookStrtegy的初始化：</p><pre><code>const FacebookStrategy = require(&apos;passport-facebook&apos;).Strategy;passport.use(new FacebookStrategy({    callbackURL: &apos;/auth/facebook/redirect&apos;,    clientID: credentials.facebook.clientID,    clientSecret: credentials.facebook.clientSecret},function(accessToken, refreshToken, profile, done) {    // 如果用户已经存在    User.findOne({provider_and_id: `facebook_${profile.id}`}).then((currentUser) =&gt; {        if(currentUser){            // already have this user            console.log(&apos;user is: &apos;, currentUser);            // do something            done(null, currentUser);        } else {            // if not, create user in our db            console.log(profile);            new User({                provider_and_id: `facebook_${profile.id}`,                username: profile.displayName,                thumbnail: profile.profileUrl            }).save().then((newUser) =&gt; {                console.log(&apos;created new user: &apos;, newUser);                // do something                done(null, newUser);            });        }    });}));</code></pre><p>其余部分，比如： /auth/facebook，/auth/facebook/redirect的路由和Google登录类似，这里就不赘叙了。</p>]]></content>
    
    <summary type="html">
    
      如何在Express.js中使用OAuth(Google,Facebook等)进行登录
    
    </summary>
    
      <category term="技术" scheme="https://www.aafeng.uk/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Javascript" scheme="https://www.aafeng.uk/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>Nodejs开发常用库总结</title>
    <link href="https://www.aafeng.uk/nodejs-libraries/"/>
    <id>https://www.aafeng.uk/nodejs-libraries/</id>
    <published>2021-07-05T08:35:22.457Z</published>
    <updated>2021-07-12T10:49:58.757Z</updated>
    
    <content type="html"><![CDATA[<h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><h3 id="超快的Vite"><a href="#超快的Vite" class="headerlink" title="超快的Vite"></a>超快的Vite</h3><pre><code>yarn add vite -D</code></pre><p>更改package.json:</p><pre><code>&quot;scripts&quot;: {    &quot;dev&quot;: &quot;vite --host 0.0.0.0&quot;},</code></pre><p>运行：</p><pre><code>npm run dev</code></pre><h2 id="File"><a href="#File" class="headerlink" title="File"></a>File</h2><h3 id="File-type"><a href="#File-type" class="headerlink" title="File type"></a>File type</h3><p>安装：</p><pre><code>npm install --save file-type</code></pre><h3 id="Image操作"><a href="#Image操作" class="headerlink" title="Image操作"></a>Image操作</h3><p>jimp</p>]]></content>
    
    <summary type="html">
    
      Nodejs开发常用库总结
    
    </summary>
    
      <category term="技术" scheme="https://www.aafeng.uk/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Javascript" scheme="https://www.aafeng.uk/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>React Query</title>
    <link href="https://www.aafeng.uk/react-query/"/>
    <id>https://www.aafeng.uk/react-query/</id>
    <published>2021-07-03T15:33:35.594Z</published>
    <updated>2021-07-03T15:34:23.177Z</updated>
    
    <content type="html"><![CDATA[<p>最近试用了一下React Query，感觉真的很香，在考虑是否在项目中引入这个出色的库。</p><p><img src="https://user-images.githubusercontent.com/63479035/124358737-86df3400-dc19-11eb-9cfc-11dc7a7976af.png" alt="image"><br>图源：官网截图</p><a id="more"></a><p>在React APP中不可避免的要调用很多REST API对数据进行CRUD操作。对于每一个API endpoint，我们都需要考虑状态管理，数据同步，缓存，错误处理等诸多细节。这就会使我们的程序变得非常臃肿。而有了React Query，无需借助全局状态，就能实现这些功能。</p><p>如果不使用React Query，最常见的方式就是使用useState及useEffect来实现状态的管理。比如：使用一个state来管理loading，另一个state来关联error，再找一个state来关联真正的数据。这样，在每一个调用API获取数据的部分都需要将调用API的状态和这些状态变量关联，非常繁琐。</p><p>同时，还会有一些其他的问题，比如：</p><ul><li>如果数据在不同人之间共享，那么当别人更改了你正在读取数据的时候，你的数据其实就已经“过时”了。怎么解决这种问题？</li><li>维护一个本地缓存并在需要的时候使数据过期，并发出新的数据请求</li></ul><p>这时可以通过自定义一个hook来处理数据的获取及各种状态，比如loading，error等。这样就可以在初始获取后缓存数据，在后台重新获取数据等。</p><p>React Query是通过维护一个服务器状态树来管理服务端状态的。同时，在React Query中还有它特有的缓存策略，来进行数据的存储和更新。这样，我们就可以把所有和服务器端相关的状态从其他状态管理库中提取出来，交给React Query。</p><p>目前唯一顾虑的就是React Query不是React官方维护的。这就存在一种潜在的风险，和Redux类似。早期的时候很多项目中都使用了Redux。但现在在最新的React版本中，不使用Redux也能进行全局状态的管理。那么是否在将来，React官方也会把React Query做的事情自己实现了呢？</p>]]></content>
    
    <summary type="html">
    
      React Query
    
    </summary>
    
      <category term="技术" scheme="https://www.aafeng.uk/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>在线开发工具总结</title>
    <link href="https://www.aafeng.uk/online-devtool/"/>
    <id>https://www.aafeng.uk/online-devtool/</id>
    <published>2021-06-29T09:17:45.879Z</published>
    <updated>2021-07-10T07:52:35.556Z</updated>
    
    <content type="html"><![CDATA[<h2 id="在线测试REST-API工具"><a href="#在线测试REST-API工具" class="headerlink" title="在线测试REST API工具"></a>在线测试REST API工具</h2><h3 id="hoppscotch"><a href="#hoppscotch" class="headerlink" title="hoppscotch"></a>hoppscotch</h3><p><a href="https://hoppscotch.io/" rel="external nofollow noopener noreferrer" target="_blank">https://hoppscotch.io/</a></p><h3 id="reqbin"><a href="#reqbin" class="headerlink" title="reqbin"></a>reqbin</h3><p><a href="https://reqbin.com/" rel="external nofollow noopener noreferrer" target="_blank">https://reqbin.com/</a></p><h3 id="测试Web-sockets"><a href="#测试Web-sockets" class="headerlink" title="测试Web sockets"></a>测试Web sockets</h3><p><a href="https://websocket.org/echo.html" rel="external nofollow noopener noreferrer" target="_blank">https://websocket.org/echo.html</a></p><h2 id="在线API-endpoints"><a href="#在线API-endpoints" class="headerlink" title="在线API endpoints"></a>在线API endpoints</h2><p>这里有很全面的列表：<a href="https://github.com/public-apis/public-apis" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/public-apis/public-apis</a></p><h3 id="starwars-API"><a href="#starwars-API" class="headerlink" title="starwars API"></a>starwars API</h3><p><a href="https://swapi.dev/" rel="external nofollow noopener noreferrer" target="_blank">https://swapi.dev/</a></p><h3 id="jokes"><a href="#jokes" class="headerlink" title="jokes"></a>jokes</h3><p><a href="https://api.icndb.com/jokes" rel="external nofollow noopener noreferrer" target="_blank">https://api.icndb.com/jokes</a><br><a href="https://api.icndb.com/jokes/random" rel="external nofollow noopener noreferrer" target="_blank">https://api.icndb.com/jokes/random</a><br><a href="https://api.icndb.com/jokes/1" rel="external nofollow noopener noreferrer" target="_blank">https://api.icndb.com/jokes/1</a></p><h3 id="news"><a href="#news" class="headerlink" title="news"></a>news</h3><p><a href="https://newsapi.org/" rel="external nofollow noopener noreferrer" target="_blank">https://newsapi.org/</a></p><h3 id="JSON-server"><a href="#JSON-server" class="headerlink" title="JSON server"></a>JSON server</h3><p><a href="https://jsonplaceholder.typicode.com/" rel="external nofollow noopener noreferrer" target="_blank">https://jsonplaceholder.typicode.com/</a></p><h2 id="Design-tool"><a href="#Design-tool" class="headerlink" title="Design tool"></a>Design tool</h2><p><a href="https://www.canva.com/" rel="external nofollow noopener noreferrer" target="_blank">https://www.canva.com/</a></p>]]></content>
    
    <summary type="html">
    
      在线开发工具总结
    
    </summary>
    
      <category term="技术" scheme="https://www.aafeng.uk/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>React开发常用组件总结</title>
    <link href="https://www.aafeng.uk/react-libraries/"/>
    <id>https://www.aafeng.uk/react-libraries/</id>
    <published>2021-06-25T20:27:35.714Z</published>
    <updated>2021-07-05T19:30:51.147Z</updated>
    
    <content type="html"><![CDATA[<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="JSON-Server"><a href="#JSON-Server" class="headerlink" title="JSON Server"></a>JSON Server</h3><p>安装：</p><pre><code>npm install -g json-server</code></pre><p>运行：</p><pre><code>json-server --watch data/db.json --port 8000 -H 0.0.0.0</code></pre><h2 id="UI相关"><a href="#UI相关" class="headerlink" title="UI相关"></a>UI相关</h2><p>react-hook-form: <a href="https://github.com/react-hook-form/react-hook-form" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/react-hook-form/react-hook-form</a><br>react-loader-spinner: <a href="https://github.com/mhnpd/react-loader-spinner" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/mhnpd/react-loader-spinner</a><br>styled-components: <a href="https://github.com/styled-components/styled-components" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/styled-components/styled-components</a><br>File Uploader: react-images-upload</p>]]></content>
    
    <summary type="html">
    
      React开发常用组件总结
    
    </summary>
    
      <category term="技术" scheme="https://www.aafeng.uk/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="React" scheme="https://www.aafeng.uk/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>试用Notion笔记软件</title>
    <link href="https://www.aafeng.uk/notion/"/>
    <id>https://www.aafeng.uk/notion/</id>
    <published>2021-06-21T18:52:58.790Z</published>
    <updated>2021-06-21T18:53:26.249Z</updated>
    
    <content type="html"><![CDATA[<p>最近经同事推荐尝试了一下Notion这个软件，感觉还是不错的。</p><p><img src="https://user-images.githubusercontent.com/63479035/122812401-8a91c300-d2c9-11eb-9b75-35f03c9da8da.png" alt="image"></p><p>其实使用Evernote已经好多年了。最早选择它的时候还没有Onenote。后来有了Onenote之后又懒得再换了。这么多年下来，在Evernote上保存了很多笔记。</p><p>对于Evernote，个人感觉这个软件整体做的还不错，但总感觉其中的功能有些让人不是特别满意。比如：免费版本只能在两个设备间同步数据；不支持程序代码的高亮显示。</p><p>在试用了Notion之后，被其强悍的功能所折服。打算下一步正式用一段时间，看看是否真的好用。</p><p>在我看来，Notion具有以下优点。</p><p>首先就是其灵活性。在Notion中，可以管理笔记，进行项目管理，待办事情列表等等。也就是说，在Notion中，针对使用者的约束会更少，让使用者有更大的空间自由发挥。</p><p>其次，就算在笔记这项最为重要的功能中，也有很多亮点。比如，在表格中可以进行统计。这不是把Excel的功能也搞进来了吗？</p><p>还有就是其强大的Markdown支持，对常见编程语言代码的高亮显示等功能。</p><p>当然，版本备份功能也是必不可少的。在Notion中可以查看自己的修改记录。</p><p>还有很多我尚未尝试的功能，比如：gallery，calender，board，数学公式等等。</p><p>不过，自己对Notion的界面不是很喜欢。反倒是Evernote的界面更对我的胃口。其实也讲不出原因，第一眼喜欢就是喜欢，反之亦然。就像我从第一眼看见Netbeans的时候就产生一种排斥感，但对于eclipse就出奇的喜欢。不论怎样，先进一步试用一下吧，毕竟，它所提供的功能更为重要。</p>]]></content>
    
    <summary type="html">
    
      试用Notion笔记软件
    
    </summary>
    
      <category term="生活" scheme="https://www.aafeng.uk/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>useContext+reducers+local storage</title>
    <link href="https://www.aafeng.uk/usecontext/"/>
    <id>https://www.aafeng.uk/usecontext/</id>
    <published>2021-06-20T22:03:57.000Z</published>
    <updated>2021-06-24T09:56:35.443Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在React中，Context API提供了一种简洁又干净的方法在不同组件中共享状态。 其典型应用场景包括： 用户认证，界面语言，主题等“全局”性的设置。</p><p><img src="https://user-images.githubusercontent.com/63479035/123172610-47745300-d475-11eb-93b9-f8e06387ac02.png" alt="image"><br>Source: Pixabay</p><a id="more"></a><h2 id="使用Context-Provider"><a href="#使用Context-Provider" class="headerlink" title="使用Context Provider"></a>使用Context Provider</h2><p>要想使用上下文，首先需要创建上下文的提供者： Context Provider。 比如：想要创建一个和用户认证相关的上下文。</p><p>首先，添加src/contexts/LoginContext.js:</p><pre><code>import React, { createContext, useState } from &apos;react&apos;;export const LoginContext = createContext();export default function LoginContextProvider({ children }) {    const [isAuthenticated, setIsAuthenticated] =  useState(false);    const [role, setRole] =  useState(&apos;public&apos;);    const login = () =&gt; {        setIsAuthenticated(true);    }    const logout = () =&gt; {        setIsAuthenticated(false);        setRole(&apos;&apos;);    }    return (        &lt;LoginContext.Provider value={{ isAuthenticated, login, logout, role, setRole }}&gt;            { children }        &lt;/LoginContext.Provider&gt;    )}</code></pre><p>对其进行调用的组件：</p><pre><code>import React, { useContext } from &apos;react&apos;;import {LoginContext} from &apos;../contexts/LoginContext&apos;;export default function LoginTest() {    const loginContext = useContext(LoginContext);    const { isAuthenticated, login, logout, role, setRole } = loginContext;    return (        &lt;div style={{margin: "25px"}}&gt;            You are {isAuthenticated? &quot;logged in.&quot;: &quot;logged out.&quot;}&lt;br/&gt;            Your role: {role}&lt;br/&gt;            &lt;button onClick={isAuthenticated? logout:login}&gt;{isAuthenticated? &quot;Logout&quot;:&quot;Login&quot;}&lt;/button&gt;            &lt;button onClick={() =&gt; setRole(&apos;Admin&apos;)}&gt;Change role to Admin&lt;/button&gt;            &lt;button onClick={() =&gt; setRole(&apos;public&apos;)}&gt;Change role to public&lt;/button&gt;        &lt;/div&gt;    )}</code></pre><p>在App.js中，</p><pre><code>&lt;LoginContextProvider&gt;    &lt;LoginTest/&gt;&lt;/LoginContextProvider&gt;</code></pre><p><img src="https://user-images.githubusercontent.com/63479035/123218024-20447280-d4c3-11eb-8c49-4e668a348c83.png" alt="image"></p><h2 id="使用Context-Provider保存全局数据"><a href="#使用Context-Provider保存全局数据" class="headerlink" title="使用Context Provider保存全局数据"></a>使用Context Provider保存全局数据</h2><p>有些时候甚至可以把数据放到Context Provider中，比如：</p><pre><code>import React, { createContext, useState } from &apos;react&apos;;export const BookContext = createContext();const BookContextProvider = ({children}) =&gt; {  const [books, setBooks] = useState([    {title: &apos;Java程序设计&apos;, id: 1101},    {title: &apos;Python程序设计&apos;, id: 1102},    {title: &apos;React in Action&apos;, id: 1103},  ]);  return (    &lt;BookContext.Provider value={{books}}&gt;      {children}    &lt;/BookContext.Provider&gt;  )}export default BookContextProvider;</code></pre><p>在组件中使用BookContext:</p><pre><code>const { books } = useContext(BookContext);</code></pre><p>这样就可以在不同组件中共享 books 实例。</p><h2 id="使用reducer"><a href="#使用reducer" class="headerlink" title="使用reducer"></a>使用reducer</h2><p>首先，在使用Context Provider的时候，不是必须使用reducer的，但如果使用，可以简化代码。比如，在CustomerContextProvider中，我们可以添加addCustomer, removeCustomer等方法并把它们传递给使用Context的组件中，但这样做对于简单应用还好。对于稍微复杂的应用，就会过于烦琐了。最好的方法是使用reducer将这些方法统一进行管理。</p><h3 id="创建reducer"><a href="#创建reducer" class="headerlink" title="创建reducer"></a>创建reducer</h3><p>首先，需要创建一个Reducer，并将操纵状态的逻辑放在reducer中：</p><pre><code>import uuid from &apos;react-uuid&apos;;export const customerReducer = (state, action) =&gt; {  switch (action.type) {    case &apos;ADD_CUSTOMER&apos;:      return [...state, {        name: action.customer.name,         phone: action.customer.phone,         id: uuid()}      ];    case &apos;REMOVE_CUSTOMER&apos;:      return state.filter(customer =&gt; customer.id !== action.id);    case &apos;ADD_DUMMY_CUSTOMERS&apos;:      return [        {id: uuid(), name: &apos;Stuart&apos;, phone: &apos;07853110066&apos;},        {id: uuid(), name: &apos;Lucas&apos;, phone: &apos;07853110067&apos;},        {id: uuid(), name: &apos;Andy&apos;, phone: &apos;07853110068&apos;}      ];        case &apos;RESET_CUSTOMER&apos;:      return [];        default:      return state;  }} </code></pre><h3 id="在ContextProvider中使用reducer"><a href="#在ContextProvider中使用reducer" class="headerlink" title="在ContextProvider中使用reducer"></a>在ContextProvider中使用reducer</h3><p>接下来，在CustomerContext中，就不要使用useState，而是使用useReducer了。因为state的管理已经转移到reducer中了。</p><pre><code>import React, { createContext, useReducer } from &apos;react&apos;;import { customerReducer } from &apos;../reducers/customerReducer&apos;;export const CustomerContext = createContext();const CustomerContextProvider = (props) =&gt; {  const [customers, dispatch] = useReducer(customerReducer, []);  return (    &lt;CustomerContext.Provider value={{ customers, dispatch }}&gt;      {props.children}    &lt;/CustomerContext.Provider&gt;  );}export default CustomerContextProvider;</code></pre><h3 id="在UI组件中使用Context和reducer"><a href="#在UI组件中使用Context和reducer" class="headerlink" title="在UI组件中使用Context和reducer"></a>在UI组件中使用Context和reducer</h3><p>接下来在UI组件中只需要通过传递给dispatch相应的参数就可以调用相应的状态更新方法了：</p><pre><code>import React, { useContext } from &apos;react&apos;;import { CustomerContext } from &apos;../contexts/CustomerContext&apos;;export default function CustomerList() {    const customerContext = useContext(CustomerContext);    const { customers, dispatch } = customerContext;    return (        &lt;div&gt;            Current customers (click to delete):            &lt;hr/&gt;            &lt;ul&gt;            {customers.map(customer =&gt; {                return (                     &lt;li key={customer.id} onClick={() =&gt; dispatch({ type: &apos;REMOVE_CUSTOMER&apos;, id: customer.id })}&gt;{customer.name} / {customer.phone}&lt;/li&gt;                );            })}            &lt;/ul&gt;            &lt;button onClick={() =&gt; dispatch({ type: &apos;ADD_DUMMY_CUSTOMERS&apos; })}&gt;Add dummy customers&lt;/button&gt;            &lt;button onClick={() =&gt; dispatch({ type: &apos;RESET_CUSTOMER&apos; })}&gt;Reset customers&lt;/button&gt;        &lt;/div&gt;    )}</code></pre><h2 id="Local-Storage"><a href="#Local-Storage" class="headerlink" title="Local Storage"></a>Local Storage</h2><p>key value pairs</p><p>值必须为字符串类型。</p><p>需要将JSON转换为字符串后才能够保存到local storage。<br>customer = {“name”:”George”,”phone”:”07882223333”}<br>localStorage.setItem(‘c1’, JSON.stringify(customer))</p><p>因此在读取后需要再次转换为JSON：<br>george = JSON.parse(localStorage.getItem(‘c1’))</p><p>如果想要使用local storage，在CustomerContext.js中：</p><pre><code>const [customers, dispatch] = useReducer(customerReducer, [], () =&gt; {    const localData = localStorage.getItem(&apos;customers&apos;);    return localData ? JSON.parse(localData) : [];});useEffect(() =&gt; {    localStorage.setItem(&apos;customers&apos;, JSON.stringify(customers));}, [customers]);</code></pre>]]></content>
    
    <summary type="html">
    
      使用Context Provider及useContext管理React中的上下文, 使用reducer，local storage
    
    </summary>
    
      <category term="技术" scheme="https://www.aafeng.uk/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>安装eufy家用安全摄像头</title>
    <link href="https://www.aafeng.uk/eufy-security-camera/"/>
    <id>https://www.aafeng.uk/eufy-security-camera/</id>
    <published>2021-06-20T21:45:13.701Z</published>
    <updated>2021-06-21T17:34:39.529Z</updated>
    
    <content type="html"><![CDATA[<p>最近不断听到伦敦等地出现一些暴力事件，于是就考虑在家安装一组安全摄像头。经朋友推荐，选择了eufyCam家用摄像头。</p><p><img src="https://user-images.githubusercontent.com/63479035/122688729-e8fd6980-d215-11eb-88ac-5eb548406ffb.png" alt="image"></p><a id="more"></a><p>其实，我所在的小城安全系数本来就很高。我所住的街区也从未听说过入室盗窃的事件。不过安装一下毕竟还是有好处的。至少在有人敲门的时候能够看清对方。</p><p>在网上下单后，很快就送到了。官网说的是3-7个工作日，但没有想到第二天就送到了。奇怪的是，竟然是Amazon Prime的包装。可能两家是有合作吧。</p><p>整个安装过程还是非常简单的。</p><p>首先是把主机通过网线和家中的路由器连接在一起，然后进行了初始设置。</p><p>然后从Google Play Store上安装了他家的APP，在APP中根据提示添加了主机，以及两个配套的摄像头。这里需要注意的是，在选择摄像头位置的时候，需要拿着摄像头看看WIFI信号是否足够强。</p><p>接下来就是把摄像头安装到户外了。说明书上提到，一定要避免阳光的直接照射。这主要是因为摄像头内置有电池，在阳光暴晒下可能会有危险。不过话说，安装在户外，又要避免阳光，似乎并不容易。我选择安装在排水管道的下方，肯定会被照到，但应该还好吧。</p><p>安装好之后，只要有人走进，手机APP就会有提示。摄像头还有白天和夜间模式两种。同时，它还有人脸识别功能，能够检测到走进的人。APP内部还有宠物识别功能。但对于我来说，似乎没什么用。</p><p>安装完毕后，倒没有觉得更安全了，但却感觉很好玩。随时可以看到家附近情况的感觉还是很不错的。</p><p>如果喜欢的话，欢迎使用我的<a href="https://bit.ly/3cSjKBW" rel="external nofollow noopener noreferrer" target="_blank">推荐链接</a>，你能获得40英镑的折扣（订单超过200英镑，且为原价商品才能获得折扣），我则会获得40英镑的Amazon购物券。也算是双赢吧。</p>]]></content>
    
    <summary type="html">
    
      安装eufy家用安全摄像头
    
    </summary>
    
      <category term="生活" scheme="https://www.aafeng.uk/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>英国的茴香</title>
    <link href="https://www.aafeng.uk/fennel/"/>
    <id>https://www.aafeng.uk/fennel/</id>
    <published>2021-06-12T20:15:09.937Z</published>
    <updated>2021-06-12T20:15:46.032Z</updated>
    
    <content type="html"><![CDATA[<p>今年英国的天气很古怪。5月份之前一直气温很低。第一批育好的苗种到外面后因为低温基本上都挂了。但最近的温度一直居高不下，有了夏天的感觉。第二批苗长势良好。</p><p>西红柿和蚕豆已经开花了。豆角也即将爬上架子了，角瓜似乎正在酝酿力量，准备爆发。尤其是茴香的长势非常好，家人看到照片后提醒，如果再不吃就要老了。<br><img src="https://user-images.githubusercontent.com/63479035/121783619-8c5fd600-cba7-11eb-8d1d-b0e362b5f12b.png" alt="image"></p><a id="more"></a><p>奇怪的是，在英国超市中也能买到茴香，但确实和国内的很不相同：根部很大，几乎没有叶子。用英国这种茴香做馅，几乎就吃不出茴香味道。。。<br><img src="https://user-images.githubusercontent.com/63479035/121787974-7232f180-cbc1-11eb-9678-862d871d3c16.png" alt="image"><br>Source: Pixabay</p><p>对于我家这株疯长的茴香，我想既然在英国，那么根部一定非常巨大了。那么好吧，我就连根带叶子一起吃了。</p><p>于是满怀期待的连根拔起：<br><img src="https://user-images.githubusercontent.com/63479035/121783673-e5c80500-cba7-11eb-8936-d58e2608f5cb.png" alt="image"></p><p>嗯？根怎么是这样的？？？无论如何，这多么大一株茴香，用来做馅应该是足够了。</p><p>很快，猪肉茴香馅的馅饼，啊不，茴香盒子：<br><img src="https://user-images.githubusercontent.com/63479035/121783699-0a23e180-cba8-11eb-8b61-70c362681378.png" alt="image"></p><p>看来这种茴香才是我记忆中的茴香，记忆中的味道。以后必须要继续种这种茴香了。。。</p>]]></content>
    
    <summary type="html">
    
      英国的茴香
    
    </summary>
    
      <category term="美食" scheme="https://www.aafeng.uk/categories/%E7%BE%8E%E9%A3%9F/"/>
    
    
  </entry>
  
</feed>
